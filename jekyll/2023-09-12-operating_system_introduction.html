<!DOCTYPE HTML>
<html lang="en" >
    <head><meta charset="UTF-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="google-site-verification" content="MrJpPCJ8htzZlGpC1wo97QA1_XWns05Ez0LBsW3wj3I" /><title>OS | Operating System Introduction · Home</title><meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="description" content="Build Jekyll site with the GitBook style.
"><meta name="generator" content="Jekyll (using style of GitBook 3.2.3)"><meta name="author" content="Benson Hsu"><link rel="stylesheet" href="/assets/gitbook/style.css">
<link rel="stylesheet" href="/assets/gitbook/gitbook-plugin-back-to-top-button/plugin.css">
<link rel="stylesheet" href="/assets/gitbook/gitbook-plugin-expandable-chapters-small2/expandable-chapters-small.css">
<link rel="stylesheet" href="/assets/gitbook/gitbook-plugin-fontsettings/website.css">
<link rel="stylesheet" href="/assets/gitbook/gitbook-plugin-search-pro/search.css">
<link rel="stylesheet" href="/assets/gitbook/gitbook-plugin-splitter/splitter.css">

<link rel="stylesheet" href="/assets/gitbook/rouge/colorful.css">

<link rel="stylesheet" href="/assets/gitbook/custom.css">
<link rel="stylesheet" href="/assets/gitbook/custom-local.css">

<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/assets/gitbook/images/apple-touch-icon-precomposed-152.png">
<link rel="shortcut icon" href="/assets/gitbook/images/favicon.ico" type="image/x-icon">




            <link rel="prev" href="/jekyll/2023-09-07-test_case_generation_based_on_constraint_logic_graph.html" />
        

        
            <link rel="next" href="/jekyll/2023-09-20-compiler_introduction.html" />
        
    </head>
    <body>
        <div class="book"><div class="book-summary">
    <script type="text/javascript">
        // Fixes the page links scroll problem on both desktop and mobile browsers
        function pageScrollToTop(element) {
            // both mobile and non-mobile
            $('div.body-inner').animate({scrollTop: 0});
            $(element).parent().find('li>ul>li').removeClass('active');
            return true;  // propagate
        }
        // Fixes the anchor links scroll problem on mobile browsers
        function mobilePageScrollToAnchor(element) {
            $(element).closest('li.chapter').find('ul>li').removeClass('active');
            $(element).parent().addClass('active');
            if ($(document).width() <= 1240) {
                $('div.body-inner').animate({scrollTop: $($(element).attr('href')).get(0).offsetTop});
            }
            return true;
        }
    </script>

    <nav role="navigation">
        <div id="book-search-input" role="search">
            <input type="text" placeholder="Type to search" />
        </div>
        <div id="book-search-input-link" role="search">
            <a href="/assets/search.html">Click to Search</a>
        </div>
        <ul class="summary">
            
            <li class="chapter" data-level="1.1" data-path="">
            
                <a href="/" onclick="pageScrollToTop(this)">
                    Home
                </a>
            </li>

            <li class="divider"></li>

            
                <!-- <p>pages</p> -->
                
                    

                    

                    
                
            
                <!-- <p>posts</p> -->
                
                    

                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2026-02-05-swagger.html">
                        
                            <a href="/jekyll/2026-02-05-swagger.html" onclick="pageScrollToTop(this)">
                                Backend | Swagger
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2026-02-02-inversion_of_control.html">
                        
                            <a href="/jekyll/2026-02-02-inversion_of_control.html" onclick="pageScrollToTop(this)">
                                Pattern | Inversion of Control
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2026-01-29-the_12_factor_app.html">
                        
                            <a href="/jekyll/2026-01-29-the_12_factor_app.html" onclick="pageScrollToTop(this)">
                                Backend | The 12-Factor App
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2026-01-26-ACPI_States.html">
                        
                            <a href="/jekyll/2026-01-26-ACPI_States.html" onclick="pageScrollToTop(this)">
                                Note | ACPI States
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2026-01-24-BIOS_introduction.html">
                        
                            <a href="/jekyll/2026-01-24-BIOS_introduction.html" onclick="pageScrollToTop(this)">
                                Note | BIOS Introduction
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2026-01-17-I2C_introduction.html">
                        
                            <a href="/jekyll/2026-01-17-I2C_introduction.html" onclick="pageScrollToTop(this)">
                                Note | I2C Introduction
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-11-21-llvm_cpu0_create_backend.html">
                        
                            <a href="/jekyll/2025-11-21-llvm_cpu0_create_backend.html" onclick="pageScrollToTop(this)">
                                LLVM | CPU0 Create Backend Machine
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-11-20-tablegen_introduction.html">
                        
                            <a href="/jekyll/2025-11-20-tablegen_introduction.html" onclick="pageScrollToTop(this)">
                                LLVM | TableGen Introduction
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-11-14-computer_organization_pipeline_hazards.html">
                        
                            <a href="/jekyll/2025-11-14-computer_organization_pipeline_hazards.html" onclick="pageScrollToTop(this)">
                                Computer Organization | Pipelines Hazards
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-11-12-computer_organization_pipeline.html">
                        
                            <a href="/jekyll/2025-11-12-computer_organization_pipeline.html" onclick="pageScrollToTop(this)">
                                Computer Organization | Pipelines
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-09-21-Resource_Acquisition_Is_Initialization.html">
                        
                            <a href="/jekyll/2025-09-21-Resource_Acquisition_Is_Initialization.html" onclick="pageScrollToTop(this)">
                                C++ | Resource Acquisition Is Initialization (RAII)
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-09-13-Big_Number_Multiplication.html">
                        
                            <a href="/jekyll/2025-09-13-Big_Number_Multiplication.html" onclick="pageScrollToTop(this)">
                                Algorithm | Big Number Multiplication
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-08-09-how_do_cpp_compiler_gen_exe_file.html">
                        
                            <a href="/jekyll/2025-08-09-how_do_cpp_compiler_gen_exe_file.html" onclick="pageScrollToTop(this)">
                                C++ | How C++ Compiler Generates Executable File
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-03-21-fluent_interface.html">
                        
                            <a href="/jekyll/2025-03-21-fluent_interface.html" onclick="pageScrollToTop(this)">
                                Pattern | Fluent Interface
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2024-10-17-KLEE_symbolic_execution.html">
                        
                            <a href="/jekyll/2024-10-17-KLEE_symbolic_execution.html" onclick="pageScrollToTop(this)">
                                Paper | KLEE: Introducing Symbolic Execution
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2024-07-28-parallel_and_distributed_systems_introduction.html">
                        
                            <a href="/jekyll/2024-07-28-parallel_and_distributed_systems_introduction.html" onclick="pageScrollToTop(this)">
                                PDS | Introduction of Parallel and Distributed Systems
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2024-06-21-competitive_paging_algorithm.html">
                        
                            <a href="/jekylls/2024-06-21-competitive_paging_algorithm.html" onclick="pageScrollToTop(this)">
                                Algorithm | Competitive Paging Algorithm
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2024-06-09-arch_user_repository.html">
                        
                            <a href="/jekylls/2024-06-09-arch_user_repository.html" onclick="pageScrollToTop(this)">
                                Note | Arch User Repository
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2024-04-09-hirschbergs_algorithm.html">
                        
                            <a href="/jekylls/2024-04-09-hirschbergs_algorithm.html" onclick="pageScrollToTop(this)">
                                Algorithm | Hirschberg&#39;s Algorithm
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2024-03-08-ANTLR_guide.html">
                        
                            <a href="/jekylls/2024-03-08-ANTLR_guide.html" onclick="pageScrollToTop(this)">
                                Compiler | ANTLR Guide
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2024-03-06-arch_linux_installation.html">
                        
                            <a href="/jekylls/2024-03-06-arch_linux_installation.html" onclick="pageScrollToTop(this)">
                                Note | Arch Linux Installation
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2024-03-01-maven_multi_module_project.html">
                        
                            <a href="/jekylls/2024-03-01-maven_multi_module_project.html" onclick="pageScrollToTop(this)">
                                Note | Apache Maven Multi-Module Project Guide
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2024-02-03-storage_and_file_system.html">
                        
                            <a href="/jekyll/2024-02-03-storage_and_file_system.html" onclick="pageScrollToTop(this)">
                                OS | Storage and File System
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2024-01-05-debian_btrfs.html">
                        
                            <a href="/jekylls/2024-01-05-debian_btrfs.html" onclick="pageScrollToTop(this)">
                                Note | Using btrfs on Debian
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2023-12-26-code_generation.html">
                        
                            <a href="/jekylls/2023-12-26-code_generation.html" onclick="pageScrollToTop(this)">
                                Compiler | Code Generation (Unfinished)
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-12-23-virtual_memory.html">
                        
                            <a href="/jekyll/2023-12-23-virtual_memory.html" onclick="pageScrollToTop(this)">
                                OS | Virtual Memory
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-12-20-system_testing.html">
                        
                            <a href="/jekyll/2023-12-20-system_testing.html" onclick="pageScrollToTop(this)">
                                Testing | System Testing
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-12-12-mutation_testing.html">
                        
                            <a href="/jekyll/2023-12-12-mutation_testing.html" onclick="pageScrollToTop(this)">
                                Testing | Mutation Testing
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-12-10-main_memory.html">
                        
                            <a href="/jekyll/2023-12-10-main_memory.html" onclick="pageScrollToTop(this)">
                                OS | Main Memory
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-12-09-class_level_testing.html">
                        
                            <a href="/jekyll/2023-12-09-class_level_testing.html" onclick="pageScrollToTop(this)">
                                Testing | Class-Level Unit Testing
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2023-11-29-semantic_analysis.html">
                        
                            <a href="/jekylls/2023-11-29-semantic_analysis.html" onclick="pageScrollToTop(this)">
                                Compiler | Semantic Analysis Notes
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-11-28-test_coverage_criteria.html">
                        
                            <a href="/jekyll/2023-11-28-test_coverage_criteria.html" onclick="pageScrollToTop(this)">
                                Note | Test Coverage Criteria
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-11-25-method_level_structural_unit_testing.html">
                        
                            <a href="/jekyll/2023-11-25-method_level_structural_unit_testing.html" onclick="pageScrollToTop(this)">
                                Testing | Method-Level Structural Unit Testing
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-11-24-deadlock.html">
                        
                            <a href="/jekyll/2023-11-24-deadlock.html" onclick="pageScrollToTop(this)">
                                OS | Deadlock
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-11-23-based_on_clp_testcases.html">
                        
                            <a href="/jekyll/2023-11-23-based_on_clp_testcases.html" onclick="pageScrollToTop(this)">
                                Testing | Based on CLP Testcases
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-11-09-synchronization.html">
                        
                            <a href="/jekyll/2023-11-09-synchronization.html" onclick="pageScrollToTop(this)">
                                OS | Synchronization (Unfinished)
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-10-28-method_level_function_unit_testing.html">
                        
                            <a href="/jekyll/2023-10-28-method_level_function_unit_testing.html" onclick="pageScrollToTop(this)">
                                Testing | Method-Level Functional Unit Testing
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2023-10-26-syntax_analysis.html">
                        
                            <a href="/jekylls/2023-10-26-syntax_analysis.html" onclick="pageScrollToTop(this)">
                                Compiler | Syntax Analysis Notes
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-10-19-cpu_scheduler.html">
                        
                            <a href="/jekyll/2023-10-19-cpu_scheduler.html" onclick="pageScrollToTop(this)">
                                OS | CPU Scheduler
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-10-18-process_thread.html">
                        
                            <a href="/jekyll/2023-10-18-process_thread.html" onclick="pageScrollToTop(this)">
                                OS | Process and Thread
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-10-17-container_of.html">
                        
                            <a href="/jekyll/2023-10-17-container_of.html" onclick="pageScrollToTop(this)">
                                Note | Linux Kernel Macro container_of &amp; offsetof
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-10-10-test_case_generation.html">
                        
                            <a href="/jekyll/2023-10-10-test_case_generation.html" onclick="pageScrollToTop(this)">
                                Testing | Test Case Generation
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-10-09-operating_system_structure.html">
                        
                            <a href="/jekyll/2023-10-09-operating_system_structure.html" onclick="pageScrollToTop(this)">
                                OS | Operating System Structure
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-09-23-software_testing_introduction.html">
                        
                            <a href="/jekyll/2023-09-23-software_testing_introduction.html" onclick="pageScrollToTop(this)">
                                Testing | Software Testing Introduction
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2023-09-21-lexical_analysis.html">
                        
                            <a href="/jekylls/2023-09-21-lexical_analysis.html" onclick="pageScrollToTop(this)">
                                Compiler | Lexical Analysis Notes
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-09-20-compiler_introduction.html">
                        
                            <a href="/jekyll/2023-09-20-compiler_introduction.html" onclick="pageScrollToTop(this)">
                                Compiler | Compilers Introduction
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter active" data-level="1.2" data-path="/jekyll/2023-09-12-operating_system_introduction.html">
                        
                            <a href="/jekyll/2023-09-12-operating_system_introduction.html" onclick="pageScrollToTop(this)">
                                OS | Operating System Introduction
                            </a>
                            
                                
                                    <ul><li><a href="#introduction" onclick="mobilePageScrollToAnchor(this)" >Introduction</a></li><li><a href="#main-memory" onclick="mobilePageScrollToAnchor(this)" >Main Memory</a></li><li><a href="#io-subsystem" onclick="mobilePageScrollToAnchor(this)" >I/O Subsystem</a></li><li><a href="#io-subsystem-notify-the-cpu" onclick="mobilePageScrollToAnchor(this)" >I/O Subsystem notify the CPU</a></li><li><a href="#scheduler-and-file-system" onclick="mobilePageScrollToAnchor(this)" >Scheduler and File System</a></li><li><a href="#hardware-progress" onclick="mobilePageScrollToAnchor(this)" >Hardware progress</a></li><li><a href="#driver-architecture" onclick="mobilePageScrollToAnchor(this)" >Driver Architecture</a></li><li><a href="#start-the-os" onclick="mobilePageScrollToAnchor(this)" >Start the OS</a></li></ul>

                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-09-07-test_case_generation_based_on_constraint_logic_graph.html">
                        
                            <a href="/jekyll/2023-09-07-test_case_generation_based_on_constraint_logic_graph.html" onclick="pageScrollToTop(this)">
                                Paper | Test Case Generation Based on Constraint Logic Graph
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-09-07-Introduction_OCL.html">
                        
                            <a href="/jekyll/2023-09-07-Introduction_OCL.html" onclick="pageScrollToTop(this)">
                                Note | Object Constraint Language Concepts (Unfinished)
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-08-06-gdb_introduction.html">
                        
                            <a href="/jekyll/2023-08-06-gdb_introduction.html" onclick="pageScrollToTop(this)">
                                Note | GNU Debugger Quick Notes
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-08-05-linux_kernel_complie.html">
                        
                            <a href="/jekyll/2023-08-05-linux_kernel_complie.html" onclick="pageScrollToTop(this)">
                                OS | Linux Kernel Compilation
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-07-28-UML_structure_diagrams.html">
                        
                            <a href="/jekyll/2023-07-28-UML_structure_diagrams.html" onclick="pageScrollToTop(this)">
                                Note | UML Structure Diagrams Introduction
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-07-28-UML_behavior_diagrams.html">
                        
                            <a href="/jekyll/2023-07-28-UML_behavior_diagrams.html" onclick="pageScrollToTop(this)">
                                Note | UML Behavior Diagrams Introduction (Unfinished)
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-07-26-unified_modeling_language.html">
                        
                            <a href="/jekyll/2023-07-26-unified_modeling_language.html" onclick="pageScrollToTop(this)">
                                Note | Unified Modeling Language Concepts
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-07-22-property_based_testing_entropy_guided_backbox_REST_API-_fuzzer.html">
                        
                            <a href="/jekyll/2023-07-22-property_based_testing_entropy_guided_backbox_REST_API-_fuzzer.html" onclick="pageScrollToTop(this)">
                                Paper | BenFuzz: A Property Based Testing and Entropy Guided Blackbox REST API Fuzzer
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-07-19-MVVM_modeling_methodology_user_interface.html">
                        
                            <a href="/jekyll/2023-07-19-MVVM_modeling_methodology_user_interface.html" onclick="pageScrollToTop(this)">
                                Paper | A MVVM Modeling Methodology for Information Systems User Interface Design
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-07-18-software_arch_pattern.html">
                        
                            <a href="/jekyll/2023-07-18-software_arch_pattern.html" onclick="pageScrollToTop(this)">
                                Note | Architectural Patterns Compare MVP, MVC, MVVM
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-07-18-automated_gen_test_case_using_UML.html">
                        
                            <a href="/jekyll/2023-07-18-automated_gen_test_case_using_UML.html" onclick="pageScrollToTop(this)">
                                Paper | Automated-generating test case using UML statechart diagrams (Unfinished)
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-06-23-Intergrated_environment_sdd.html">
                        
                            <a href="/jekyll/2023-06-23-Intergrated_environment_sdd.html" onclick="pageScrollToTop(this)">
                                Paper | An Integrated Environment for Specification Driven Development (Unfinished)
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-05-28-characteristics_of_bdd.html">
                        
                            <a href="/jekyll/2023-05-28-characteristics_of_bdd.html" onclick="pageScrollToTop(this)">
                                Paper | A Study of the Characteristics of Behaviour Driven Development
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-05-20-analysis_mutation_testing.html">
                        
                            <a href="/jekyll/2023-05-20-analysis_mutation_testing.html" onclick="pageScrollToTop(this)">
                                Paper | An Analysis and Survey of the Development of Mutation Testing
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-04-21-tdd_concepts.html">
                        
                            <a href="/jekyll/2023-04-21-tdd_concepts.html" onclick="pageScrollToTop(this)">
                                Paper | Test-driven development concepts, taxonomy, and future direction
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-04-18-applying_isoiec25010.html">
                        
                            <a href="/jekyll/2023-04-18-applying_isoiec25010.html" onclick="pageScrollToTop(this)">
                                Paper | Applying the ISO/IEC 25010 Quality Models to Software Product
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-04-13-software_standard.html">
                        
                            <a href="/jekyll/2023-04-13-software_standard.html" onclick="pageScrollToTop(this)">
                                Note | Standard - ISO/IEC
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-02-04-algorithm_kmp.html">
                        
                            <a href="/jekyll/2023-02-04-algorithm_kmp.html" onclick="pageScrollToTop(this)">
                                Leetcode | Algorithm - KMP
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-01-12-gomoku_ai.html">
                        
                            <a href="/jekyll/2023-01-12-gomoku_ai.html" onclick="pageScrollToTop(this)">
                                Note | Gomoku AI - Game Tree
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2022-11-24-git_commit.html">
                        
                            <a href="/jekyll/2022-11-24-git_commit.html" onclick="pageScrollToTop(this)">
                                Note | Commit Message Format
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2022-11-08-ai_csp.html">
                        
                            <a href="/jekyll/2022-11-08-ai_csp.html" onclick="pageScrollToTop(this)">
                                Note | Constraint Satisfaction Problem
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2022-11-07-network_urat.html">
                        
                            <a href="/jekyll/2022-11-07-network_urat.html" onclick="pageScrollToTop(this)">
                                Note | Basic UART Concept
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2022-11-05-docker_jekyll.html">
                        
                            <a href="/jekyll/2022-11-05-docker_jekyll.html" onclick="pageScrollToTop(this)">
                                Note | Docker Build Github Pages
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/1970-01-01-virtual_machine_tool.html">
                        
                            <a href="/jekyll/1970-01-01-virtual_machine_tool.html" onclick="pageScrollToTop(this)">
                                Tool | Virtual Machine
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/1970-01-01-linux_config.html">
                        
                            <a href="/jekyll/1970-01-01-linux_config.html" onclick="pageScrollToTop(this)">
                                Tool | Linux Config
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/1970-01-01-leetcode_guide.html">
                        
                            <a href="/jekyll/1970-01-01-leetcode_guide.html" onclick="pageScrollToTop(this)">
                                Leetcode | Master Guide
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/1970-01-01-editor_envirmnment.html">
                        
                            <a href="/jekyll/1970-01-01-editor_envirmnment.html" onclick="pageScrollToTop(this)">
                                Tool | Edirot Guide
                            </a>
                            
                                
                            
                        </li>
                    

                    
                        <li class="divider"></li>
                    
                
            
        </ul>
    </nav>
</div>
<div class="book-body">
                <div class="book-header" role="navigation">
                    <!-- Title -->
                    <h1>
                        <i class="fa fa-circle-o-notch fa-spin"></i>
                        
                            <a href="." >OS | Operating System Introduction</a>
                        
                    </h1>
                </div>

                <div class="body-inner"><div class="page-wrapper" tabindex="-1" role="main">
    

    <div class="page-inner">
        <div class="normal">
            
            
            <section class="normal">September 12, 2023 </section>
            
        </div>
        <div id="book-search-results">
            <div class="search-noresults">
                <section class="normal markdown-section">
                    
                        <h1 id="/jekyll/operating_system_introduction">OS | Operating System Introduction</h1>
                    

                    <blockquote class="block-tip">
  <p>Operating System: Design and Implementation course notes from CCU, lecturer Shiwu-Lo.</p>
</blockquote>

<h3 id="introduction">Introduction</h3>

<p><a href="./2023-09-12-operating_system_introduction.html#11-why-need-os">1.1 Why need OS</a><br />
<a href="./2023-09-12-operating_system_introduction.html#13-user-modekernel-mode">1.3 User mode/Kernel mode</a><br />
<a href="./2023-09-12-operating_system_introduction.html#15-user-spacekernel-space">1.5 User space/Kernel space</a><br />
<a href="./2023-09-12-operating_system_introduction.html#16-memory-management">1.6 Memory management</a><br />
<a href="./2023-09-12-operating_system_introduction.html#17-change-mode--system-call">1.7 Change mode &amp; System call</a><br />
<a href="./2023-09-12-operating_system_introduction.html#18-signal--systemcall">1.8 Signal &amp; Systemcall</a><br />
<a href="./2023-09-12-operating_system_introduction.html#19-monolithic-kernel">1.9 Monolithic kernel</a><br />
<a href="./2023-09-12-operating_system_introduction.html#110-kernel-module">1.10 Kernel module</a></p>

<h5 id="11-why-need-os">1.1 Why need OS</h5>

<ol>
  <li>作業系統使電腦更易於使用
    <ul>
      <li>磁碟是由 Block(通常為4K) 所組成，OS 將磁碟劃分為 File，再將檔案歸類為 Folder 才易於使用。</li>
      <li>可程式化(Programmable) 變得更容易，OS 能執行執行檔，CPU 執行不同程式碼就會有不同功能。
 OS 使程式碼抽象為執行檔，能夠從各個地方載入可執行的程式碼，並且賦予邏輯上的支援。</li>
      <li>硬體抽象化(Hardware abstraction) 如滑鼠、觸控板被 OS 抽象化為一個指標裝置，使使用者能統一操作。</li>
      <li>OS 上不會只運行一個程式，因此必須有應用程式之間的通訊，如: Copy &amp; Paste。</li>
    </ul>
  </li>
  <li>使電腦的硬體使用更有效率(資源分配)
    <ul>
      <li>一台電腦可能有多個硬體存在，OS 可以使這些硬體一起工作。</li>
      <li>例如在足夠記憶體的情況下可以同時載入多個執行檔並執行，並使用硬碟堆放暫時用不到的記憶體，以空出記憶體給真正需要的程式。</li>
      <li>透過 CPU Scheduler，使 I/O、CPU 都能維持在高使用率。</li>
    </ul>
  </li>
</ol>

<h5 id="13-user-modekernel-mode">1.3 User mode/Kernel mode</h5>

<p>大部分的作業系統以雙系統(Dual-Mode)(Linux, Windows)，可分為 User mode 與 Kernel mode:</p>

<ul>
  <li><strong>Dual mode operation</strong></li>
  <li><strong>User mode</strong>: CPU 所提供的執行模式，只能存取有限的硬體資源，如:<br />
普通運算所需的暫存器、部分記憶體內容
    <ul>
      <li>Various applications: libreoffice, gnuplot, pdf viewer</li>
      <li>GUI: X11, Gnome, KDE</li>
      <li>System manager: bash, vi, ls, mount, passwd</li>
      <li>Development tools: gcc, gdb</li>
      <li>System service: sftpd, sshd</li>
      <li>Basic inetrnet communication software: Browser, ftp</li>
      <li>Other library: courses, math</li>
      <li>Standard function library: Parts defined in POSIX like, libC, pthread</li>
    </ul>
  </li>
  <li><strong>Kernel mode</strong>: CPU 所提供的執行模式，可以對硬體做任何的變更，在 Kernel mode 能額外控制的部分如下:<br />
控制暫存器(Control register)，例如控制 MMU(Memory management unit) 的相關暫存器、所有記憶體
    <ul>
      <li>Memory management</li>
      <li>Schedule and thread management</li>
      <li>Inter-Process communication</li>
      <li>Virtual memory</li>
      <li>Network communication</li>
      <li>Scheduler</li>
      <li>File system</li>
      <li>Safety, Authority management</li>
      <li>I/O Subsystem</li>
    </ul>
  </li>
</ul>

<p>這種模式下 Kernel mode 才能完全的掌控硬體，今天如果 User mode 上的程式想要存取硬碟則需要透過 System call 來進行操作。在 Linux 的設計原則是速度第一，當然程式越靠近硬體就會更快。
但如果 User mode 想要操作硬體要透過 System call 來進行也就是改變模式(Change mode)，但這樣會產生一定的<strong>消耗</strong>。而在 Kernel mode 中進行操作硬體就只等於 Function call 的消耗而已。</p>

<ul>
  <li>User mode 想要進行切換就可能需要<strong>保存當前狀態以回復</strong>、<strong>清除 Pipeline</strong>、<strong>清除 TLB 和 Cache</strong> 這些額外消耗。</li>
  <li>Dual mode 通常需要硬體額外支援，例如提供一個 <strong>Mode bit</strong> 的暫存器來決定現在是哪一種 Mode。</li>
</ul>

<blockquote>
  <p>例如一個網頁，可以將靜態頁面放在 Kernel mode，動態頁面在 User mode。</p>
</blockquote>

<p>但不是將所有程式都放在 Kernel mode，因為只要是程式就會有 Bug，在 Kernel mode 中發生了 Bug 很可能導致整個系統的崩潰。</p>

<p><img src="/image/2023/09-12-operating_system_introduction/1.png" alt="" height="75%" width="75%" /></p>

<h5 id="15-user-spacekernel-space">1.5 User space/Kernel space</h5>

<p>虛擬記憶體(<a href="https://en.wikipedia.org/wiki/Virtual_memory">Virtual memory</a>)也分為 User/Kernel space，這主要是為了保護 Memory 與 Hardware。
CPU 在切分記憶體時每個單位會附加一些屬性，其中一個重要的屬性就是指出該單位為 User/Kernel space。</p>

<ul>
  <li>Task 之間不能讀取各自的 User space。</li>
  <li>Kernel 才能改變權限，I/O，並且擁有所有的存取權。</li>
</ul>

<table>
  <tbody>
    <tr>
      <td>可否存取</td>
      <td>Kernel space</td>
      <td>User space</td>
      <td>Privilege instructions</td>
    </tr>
    <tr>
      <td>Kernel mode</td>
      <td>✓</td>
      <td>✓</td>
      <td>✓</td>
    </tr>
    <tr>
      <td>User mode</td>
      <td> </td>
      <td>✓</td>
      <td> </td>
    </tr>
  </tbody>
</table>

<h5 id="16-memory-management">1.6 Memory management</h5>

<p>Virtual memory 的管理單位可以分為兩種，分頁(Paging)，分段(Segmentation):</p>

<ul>
  <li>Paging: 將連續的記憶體在邏輯上變成 4K 大小的 Page 方便軟、硬體對記憶體進行管理
    <ul>
      <li>這是目前最常見的做法，在管理上可以較好的分配記憶體</li>
      <li>作業系統會盡量使用 Huge page(大分頁)，一個 Huge page 可以有 2M 到 1G 的大小，因為這樣需要的 Page 數量較少，
在硬體管理上會希望 Page 盡量大一點。</li>
      <li>但是 Linux 在 User space 幾乎沒有使用大分頁，除非特別去設定要使用 Huge page，因為在軟體上管理 Page 反而 4K 可以減少記憶體浪費。</li>
    </ul>
  </li>
  <li>Segmentation: 將連續的記憶體在邏輯上變成各個大小不一的 Segment，每個 Segment 對應到程式的特定用途
    <ul>
      <li>x86 在 32 位元模式支援 segmentation</li>
      <li>Segment 在配置上比較困難，但在嵌入式系統中因為沒有什麼動態配置的需求因此較常用</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>以上的方法都需要硬體支援，是因為 CPU 與硬體的處理速度因此需要硬體支援才能使速度提升。</p>
</blockquote>

<h5 id="17-change-mode--system-call">1.7 Change mode &amp; System call</h5>

<p><strong>從 User mode 切換到 Kernel mode</strong>，是透過 <code class="language-plaintext highlighter-rouge">syscall</code> 這個組語來進行:<br />
OS init 時會告訴 CPU 當使用者呼叫 <code class="language-plaintext highlighter-rouge">syscall</code> 的時候，指令指標(%RIP Register)應該設定為何(system call 的進入點)<code class="language-plaintext highlighter-rouge">，syscall</code> 做兩件事:</p>
<ol>
  <li>保存當前的程式狀態，以便之後返回</li>
  <li>將模式切換為 Kernel mode，例如將 Mode bit 設為 0</li>
  <li>準備要被呼叫的 System call，例如在x86-64架構中的 %RAX Register 放入要被呼叫的 System call 編號</li>
</ol>

<p><strong>切換 Stack</strong>:</p>
<ul>
  <li>User space stack 一開始只配置 16K，不夠再送 Signal 給 Kernel 一次多要 4K Page 最多成長到 8M</li>
  <li>Kernel space stack 的大小並不會很大，並且 System call 也不會使用產生堆疊的寫法</li>
  <li>User/Kernel mode 的堆疊是分開的，Kernel 不能產生 fault，所以在 Kernel mode 使用的是 Kernel space stack
    <ul>
      <li>穩定性: 例如 User mode 已經故意執行了一個 7.8M 堆疊的程式，此時 Change mode 但沒有使用 Kernel space 這樣就會遇到 Segmentation fault</li>
      <li>保密性: 同時 User space stack 如果執行完沒有進行清空也有可能洩漏 Kernel 的資料</li>
    </ul>
  </li>
  <li>在 syscall 準備 system call 的時候同時還要準備執行環境，例如執行 write(clang) 就要準備好要使用的 stack 來呼叫 C 函數</li>
  <li>如果在沒辦法切換堆疊的系統上，也要盡量表留一個給 Kernel mode 使用的堆疊大小 16K</li>
</ul>

<p><strong>從 Kernel mode 回到 User mode</strong>，需要用到 <code class="language-plaintext highlighter-rouge">sysret</code> 指令來進行，此時 OS 會返回地址(接下來執行的 User mode 程式碼)<code class="language-plaintext highlighter-rouge">，sysret</code> 做兩件事:</p>
<ol>
  <li>返回 user mode 的程式碼位置，例如 x64 放在 %RCX Register</li>
  <li>切換為 user mode，例如將 Mode bit 設為 1</li>
</ol>

<blockquote class="block-tip">
  <p>不是所有的 System call 都會進行完整的 Context switch，例如 <code class="language-plaintext highlighter-rouge">getpid()</code>，就不需要把當前的程式狀態保存完整。</p>
</blockquote>

<ul>
  <li><strong>System call handler</strong> 必須確保從 Kernel 返回 User mode 時，程式<strong>將來</strong>可以<strong>繼續</strong>執行</li>
</ul>

<p>Super user 也是使用相同的 System call 進入點，大部分的 System call 會判斷權限但 <code class="language-plaintext highlighter-rouge">uid=0</code> 的時候就直接通過，General user 的 <code class="language-plaintext highlighter-rouge">uid &gt; 1000</code>。
Linux 定義了約 400 System call(Function)，大部分都透過 syscall 進入 Kernel。</p>

<h5 id="18-signal--systemcall">1.8 Signal &amp; Systemcall</h5>

<p>當 Kernel 有特別事件需要主動通知 Process，就使用 Signal 機制，Signal 接受兩個重要參數: 事件編號、發生該事件時呼叫該程式所定義的特定函數</p>
<ol>
  <li>事件編號: 例如 SIGINT 的編號是 2，表示鍵盤中斷(例如 Ctrl + C)，每種 Signal 都有唯一的編號，OS 中已被定義</li>
  <li>該事件發生時所處理的函數，可以是程式自己定義的函數或是系統默認的函數呼叫</li>
</ol>

<p>Linux kernel 只允許一個 Process 同時間發出一個 Blocking system call，需要等待 Kernel 完成該工作(System call)才回傳的系統呼叫。
當 Process 發出 Blocking system call 後，該 System call 還未結束前如果發生 signal(例如 Ctrl + C)，Kernel 該如何處理?</p>

<ol>
  <li>不理會該 Signal，繼續完成 System call</li>
  <li>處理該 Signal，該 System call 變成失敗，通常作業系統會重新起始(Redo)該 System call</li>
</ol>

<blockquote>
  <p>延伸閱讀 <a href="https://devopedia.org/linux-signals">Linux Signals</a>、<a href="https://unix.stackexchange.com/questions/16455/interruption-of-system-calls-when-a-signal-is-caught">Interruption of system calls when a signal is caught</a></p>
</blockquote>

<h5 id="19-monolithic-kernel">1.9 Monolithic Kernel</h5>

<blockquote>
  <p>假如一個人一天可以讀 1000 行程式碼，Linux kernel 的成長速度可能是一天超過 3000 行。</p>
</blockquote>

<ul>
  <li>Monolithic kernel 大部分的系統功能都設計在 Kernel mode 中，這樣的好處是執行效率，各個模組間的溝通僅為 Function call，
但同樣的 Kernel 也變得越來越複雜，也容易產生錯誤。</li>
  <li>Micro kernel 盡可能的將 OS 的系統服務執行於 User mode，讓系統變的較為穩定，
但是 User mode 的 Process 通訊需要觸發 Context switch 與 Mode change，效能較為低落。</li>
</ul>

<table>
  <thead>
    <tr>
      <th style="text-align: center">設計模式</th>
      <th style="text-align: center">系統程式</th>
      <th style="text-align: center">效能</th>
      <th style="text-align: center">核心大小</th>
      <th style="text-align: center">通訊消耗</th>
      <th style="text-align: center">OS</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Monolithic</td>
      <td style="text-align: center">大部分在 Kernel mode</td>
      <td style="text-align: center">高</td>
      <td style="text-align: center">大</td>
      <td style="text-align: center">Function call 的消耗</td>
      <td style="text-align: center">Linux, BSD</td>
    </tr>
    <tr>
      <td style="text-align: center">Micro</td>
      <td style="text-align: center">大部分在 User mode</td>
      <td style="text-align: center">低</td>
      <td style="text-align: center">小</td>
      <td style="text-align: center">Context switch 的消耗</td>
      <td style="text-align: center">Minix, L4, Android</td>
    </tr>
  </tbody>
</table>

<p>Linux 在安全性思考上可以思考 root 的權限是否太大了，root 有權看到所有的資訊，在安全性上可以透過加密來做到。</p>

<blockquote class="block-tip">
  <p>Context switch &amp; Mode change 這兩個要分清楚:</p>
  <ol>
    <li><strong>Context switch</strong>: 原本在執行 Process A，現在要換成 Process B</li>
    <li><strong>Mode change</strong>: Process A 原本執行在 User mode，因為要執行 System call 現在要切換到 Kernel mode</li>
  </ol>
</blockquote>

<h5 id="110-kernel-module">1.10 Kernel Module</h5>

<p>Kernel moduel 在意義上就是<strong>核心的插件</strong>，可以擴充核心的功能，最直觀的插件就是驅動程式。
Monolithic 設計下的 Kernel module 運行在 Kernel mode，Micro kernel 則相反。</p>

<ul>
  <li>Kernel module 在需要的時候再載入，例如 USB 如果是是一個 ext4 file system，
插入電腦後 Linux Kernel 認出後就能載入 ext4 module 來讀取該 USB</li>
  <li><code class="language-plaintext highlighter-rouge">lsmod</code> 列出目前的 Kernel module，並且 Kernel module 之間會有相依性，例如如果 Network 是一個寫好的 Kernel Module，
那它就會依賴於 Network card 的 Kernel module。</li>
</ul>

<h3 id="main-memory">Main Memory</h3>

<p><a href="./2023-09-12-operating_system_introduction.html#111-main-memory-usage">1.11 Main memory usage</a><br />
<a href="./2023-09-12-operating_system_introduction.html#112-memory-and-storage-consistency">1.12 Memory and storage consistency</a><br />
<a href="./2023-09-12-operating_system_introduction.html#113-linux-base-file-system-management">1.13 Linux base file system management</a></p>

<h5 id="111-main-memory-usage">1.11 Main memory usage</h5>

<p>Linux 將主記憶體分為三種主要用途:</p>

<ol>
  <li>Cache memory(Page cache):
    <ul>
      <li>將 Disk 或 SSD 等儲存裝置上的內容暫存於記憶體中，以提高存取速度</li>
      <li>檔案系統的 Metadata!?</li>
    </ul>
  </li>
  <li>Buffer memory:
    <ul>
      <li>與 I/O 之間的的資料交換，DMA</li>
      <li>主要是 CPU 的速度高於周邊速度，格式的轉換等等(如網路卡)</li>
    </ul>
  </li>
  <li>Program memory:
    <ul>
      <li>將記憶體分配給程式使用，如: 程式可以透過 malloc(背後的 System call 常常是 brk)、nmap 等函數索取記憶體</li>
      <li>執行檔必須載入主記憶體後才能執行</li>
    </ul>
  </li>
</ol>

<p>Linux 原則上會盡可能的使用掉所有記憶體以加速 I/O，當記憶體不足時 Linux 會釋放 Cache memory 和 Buffer memory。</p>

<p><img src="/image/2023/09-12-operating_system_introduction/2.png" alt="" height="75%" width="75%" /></p>

<h5 id="112-memory-and-storage-consistency">1.12 Memory and storage consistency</h5>

<p>主記憶體採用 DRAM 斷電後失去內容，因此需要非揮發性的第二層儲存裝置(Secondary storage，Disk, SSD)。</p>

<ul>
  <li>而電腦必須將第二層儲存裝置的內容載入記憶體後才可以供 CPU 運算
    <ul>
      <li>可以透過明確的程式碼存取資料，如: open, read, write</li>
      <li>也可以透過 mmap 的方式將檔案 Maping 到應用程式的記憶體空間加以處理</li>
    </ul>
  </li>
  <li>程式與 OS 都必須定期的將資料回存到下層裝置
    <ul>
      <li>OS 與 I/O 函數庫都可能透過 Buffering 的機制，以批次的方式寫出資料以增加效率</li>
      <li>應用程式可以呼叫函數強制將資料寫出，如: sync, fsync, fdatasyc</li>
    </ul>
  </li>
</ul>

<p>效能上的考量 read &gt; write，read 不能延遲，延遲將導致程式無法執行。<br />
結果上的考量 write &gt; read，當使用者使用 Ctrl+S 進行儲存時，若在中途當機資料並沒有真的寫入 Disk，使用者將無法接受。<br />
write 往下寫入時不一定馬上把資料寫入 Disk，有可能只是先暫時存在 Memory/Buffer 中，同時裝置上可能也會有 Buffer 例如 SSD。
這裡有例如 Write-through，Write-back 等不同方式的寫入是 OS 能進行操作的。</p>

<ul>
  <li><strong>Write-through</strong>: 寫入 Main memory 時同時寫入 Cache 這樣可以保證資料的一致性</li>
  <li><strong>Write-back</strong>: 寫入數據時先寫入 Cache，並將資料標記為 <code class="language-plaintext highlighter-rouge">dirty</code>(已修改但未寫回主記憶體)，然後在稍後的時間點將資料寫回記憶體，例如: Cache 需要新的空間來儲存新的數據</li>
</ul>

<blockquote>
  <p>深入思考，如果裝置上能有電池的話就能保證寫入時部份的安全性，如果已經寫入裝置上的 Buffer 此時電源出現意外也能短時間內進行儲存</p>
</blockquote>

<blockquote>
  <p>延伸閱讀: <a href="http://thebeardsage.com/write-through-vs-write-back/">Write-through vs Write-back</a></p>
</blockquote>

<h5 id="113-linux-base-file-system-management">1.13 Linux base file system management</h5>

<ul>
  <li>九字檔案權限管理，分為檔案與資料夾，詳情可看鳥哥的介紹 <a href="https://linux.vbird.org/linux_basic/centos7/0230filesystem.php">第七章、Linux 磁碟與檔案系統管理</a></li>
  <li>Linux 的檔案系統支援 ACL(Access control list)
    <ul>
      <li>ACL 可以對各個使用者或各個群組分別設定權限</li>
      <li>ACL 依賴底層的檔案系統支援，如: EXT4, BTRFS 等都支援 ACL</li>
      <li>可以使用指令 <code class="language-plaintext highlighter-rouge">setfval</code> 與 <code class="language-plaintext highlighter-rouge">getfacl</code> 分別設定及讀取檔案或目錄的權限</li>
    </ul>
  </li>
</ul>

<blockquote class="block-tip">
  <p>但是有時後 Normal user 也需要更改權限來執行某些程式，例如: <strong>passwd</strong>, 他會在執行中使用 <strong>setuid</strong> 來暫時改變使用者權限，
直到 <strong>passwd</strong> 執行結束(或者是該程式放棄 root 權限)</p>
</blockquote>

<p>Computer world 中的權限往往與現實世界的權限不相等</p>

<ul>
  <li>Linux 中 root 擁有最高權限，root 可以對檔案系統、應用程式(記憶體)進行各式樣的操作</li>
  <li>root 可以存取所有使用者的檔案(甚至是機密檔案)，這與真實的權限不符合(老闆 = Normal，系統管理者 = Super)</li>
  <li>目前大部分的 Linux 提供資料夾加密的功能，可以部分改善問題</li>
</ul>

<h3 id="io-subsystem">I/O Subsystem</h3>

<p><a href="./2023-09-12-operating_system_introduction.html#114-io-subsystem--control">1.14 I/O Subsystem &amp; Control</a><br />
<a href="./2023-09-12-operating_system_introduction.html#115-io-subsystem-transfers-data">1.15 I/O Subsystem transfers data</a><br />
<a href="./2023-09-12-operating_system_introduction.html#116-cpu-and-dma-compete-for-memory-access">1.16 CPU and DMA compete for memory access</a></p>

<h5 id="114-io-subsystem--control">1.14 I/O Subsystem &amp; Control</h5>

<p>周邊裝置可能有不同儲存資料的方式，例如滑鼠鍵盤可能僅需要內建暫存器，而網路卡、硬碟可能有自己的內部記憶體，儲存的資料與周邊的晶片來運作裝置。
<strong>I/O Subsystem</strong> 是 OS 的一個重要部分，負責管理程式的 I/O 請求。</p>

<p><strong>I/O Subsystem</strong> 的控制流程通常如下:</p>
<ol>
  <li>向周邊下達命令</li>
  <li>於記憶體及周邊之間做資料傳輸</li>
  <li>通知處理器「工作已完成」</li>
</ol>

<p><strong><a href="MMIO">Memory mapped I/O</a></strong><br />
目前主流使用的 I/O 方式</p>
<ul>
  <li>將周邊的控制「暫存器、記憶體」映射到 CPU 的「記憶體映射空間(Memory space)」</li>
  <li>例如使用指令: <code class="language-plaintext highlighter-rouge">MOV CX, 0xFFFFFFFF;</code> 假設 <code class="language-plaintext highlighter-rouge">0xFFFFFFFF</code> 是裝置記憶體，將 CX register 的值放到位置 <code class="language-plaintext highlighter-rouge">0xFFFFFFFF</code> 就等於向下儲存資料</li>
</ul>

<p><img src="/image/2023/09-12-operating_system_introduction/3.png" alt="" height="75%" width="75%" /></p>

<blockquote>
  <p>上圖模擬一個可能的 MMIO，DRAM 與不同的 Device 分別被映射到不同的記憶體區段。裝置有自己的控制暫存器、
去設定讀取的指令來在裝置的晶片上執行，在裝置暫存器讀寫的程式就被稱作<strong>(Device driver)驅動程式</strong></p>
</blockquote>

<p><strong><a href="PMIO">Port mapped I/O</a></strong><br />
目前在一些嵌入式處理器上使用，因為 x86 是較古老的架構因此也有支援 PMIO</p>
<ul>
  <li>使用特別的指令，將資料傳輸到特定的「Port」，注意: Port 和 Memory space 是分開的定址空間
    <ul>
      <li>x86-32 的 I/O Port 的定址空間只有 0~65535</li>
      <li>x86-32 的記憶體定址空間只有 0~4G</li>
    </ul>
  </li>
  <li>使用的指令形式如下:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">out 0x255, AX;</code> 將 AX register 寫到 0x255 Port，對裝置寫入資料</li>
      <li><code class="language-plaintext highlighter-rouge">in AX, 0x100</code> 從 0x100 Port 將資料寫到 AX register，將裝置資料取回</li>
    </ul>
  </li>
</ul>

<p><img src="/image/2023/09-12-operating_system_introduction/4.png" alt="" height="75%" width="75%" /></p>

<blockquote>
  <p>Device、Memory 分別用不同的定址方式，I/O Bus 為 64K 即最多 65536，Memory 則可以到最大 4G，這種架構下指定的速度通常比較慢，因為 MMIO 可以更簡單與直接的進行 I/O。</p>
</blockquote>

<blockquote>
  <p>延伸閱讀 <a href="https://stenlyho.blogspot.com/2008/08/io.html">I/O對應的方式</a></p>
</blockquote>

<h5 id="115-io-subsystem-transfers-data">1.15 I/O Subsystem transfers data</h5>

<p>傳輸資料上，一般來說不會使用 CPU 進行，因為 CPU 要做更重要的事。<strong>DMA(Direct memory access)</strong> 是相對簡單的硬體，
專門用來做<strong>主記憶體對主記憶體的傳輸</strong>或<strong>裝置記憶體對主記憶體的傳輸</strong>。</p>
<ul>
  <li>簡單的 DMA 只要計數器，被搬移資料的開始位置，要搬入資料的開始位置，這樣三個 Register 就完成一個能搬移連續資料的 DMA</li>
  <li>DMA 可以屬於 Bus 的一部分，如: ISA，或者是裝置的一部分，如: PCI</li>
</ul>

<p><strong>(DMA and Cache)Coherency problem</strong></p>

<p>只要有兩種介面存取同一個儲存裝置就一定會有如何同步的問題</p>

<ul>
  <li>DMA 直接存取記憶體，但 CPU 透過 Cache 存取記憶體，這造成資料不一致(Cache 的資料一定比 Main memory 新)
    <ul>
      <li>從記憶體寫出資料到裝置時，必須將 cache 的資料 flush 到記憶體(寫入主記憶體)</li>
      <li>從裝置讀取資料到記憶體時，必須先 invalid 相對應的 cache line</li>
    </ul>
  </li>
  <li>Alignment
    <ul>
      <li>DMA 傳輸的資料的開始及結束位置，通常要和 Cache(Cache line) 和 Memory 的寬度進行對齊</li>
      <li>這部分的限制可能來自於 DMA Controller 直接將資料以「固定的大小」更新到 Cache。例如: x86 是 64 個 Byte，那傳輸資料就跟 64 Byte 對齊。<em>硬體在這裡沒有特別做處理，使得非對齊的資料也可以部份更新</em></li>
    </ul>
  </li>
</ul>

<p><img src="/image/2023/09-12-operating_system_introduction/5.png" alt="" height="100%" width="100%" /></p>

<blockquote>
  <p>Disk 與 DRAM 之間的交換也要使用 buffer 來進行交換，才能避免低速讀寫去占用寶貴的 Bus 資源。當 bufdisk 將資料傳給 bufRAM 後此時要處理的就是 bufcache 與 bufRAM 之間的一致性</p>
</blockquote>

<p><strong>Cache 與 DMA 的資料不一致性解決之道</strong></p>

<ul>
  <li>(DEV =&gt; CPU) 使用硬體解決，硬體自動會將 DMA 的傳輸更新到 Cache 內(Cache coherence algorithm)
    <ul>
      <li>某些處理器，例如早期的 ARM 處理器，這部分需要特別的指令設定該段記憶體的「屬性」</li>
      <li>例如直接將該段資料直接從 cache 上完整移除(flush)，這樣就能確保 CPU 讀取記憶體時從 Main memory 讀取</li>
      <li>用硬體來進行處理的話可以分段去處理，這樣就能在分段中偷偷傳輸資料，總有一些 Cycle 沒有被使用</li>
    </ul>
  </li>
  <li>(CPU =&gt; DEV) 設定讓 CPU 在該記憶體區段進行寫入時，使用 Write through 或 Noncacheable，直達裝置上的記憶體
    <ul>
      <li><strong>Noncacheable</strong>: 直接將資料寫入該段記憶體而不透過 Buffer，這樣能確保 DMA 的資料是最新的，但會降低效能。</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>延伸閱讀 <a href="https://zhuanlan.zhihu.com/p/109919756">Cache和DMA一致性</a></p>
</blockquote>

<h5 id="116-cpu-and-dma-compete-for-memory-access">1.16 CPU and DMA compete for memory access</h5>

<ul>
  <li>如果 CPU 發生 <strong>Last-level-cache(LLC) miss</strong> 時，CPU 可能會合 DMA 爭奪存取權:
    <ul>
      <li>如果 CPU 訪問 LLC 時，如果發現沒有所需要的數據，CPU 可能會嘗試直接存取 Main memory，若此時 DMA 也正在進行存取，
就會產生爭奪存取權。</li>
      <li>DMA 每次都只傳輸小量資料，那就可以很快的禮讓控制權給 CPU，但這樣的傳輸模式很沒效率</li>
      <li>DMA 做大量傳輸可以提升 I/O 的效能，但可能會造成 CPU 等待 DMA 完成傳輸而閒置</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>延伸閱讀 <a href="https://en.wikipedia.org/wiki/Burst_mode_(computing)">Burst mode</a></p>
</blockquote>

<p><img src="/image/2023/09-12-operating_system_introduction/6.png" alt="" height="100%" width="100%" /></p>

<ul>
  <li>目前在 PCI 上每個 Device 都有自己的 DMA</li>
  <li><a href="https://en.wikipedia.org/wiki/Arbiter_(electronics)">Arbiter</a> 用來分配不同的 Device 的存取權，通常是速度越快的裝置優先權越高</li>
</ul>

<p><strong>DMA 的其他議題</strong></p>

<ul>
  <li>DMA 的定址空間
    <ul>
      <li>部分 DMA 的定址空間可能只有 32bit，OS 必須盡可能的將 DMA 能使用的記憶體保留給 DMA 使用</li>
    </ul>
  </li>
  <li>I/O MMU
    <ul>
      <li>主要讓 DMA 存取實體位置不連續的記憶體</li>
      <li>避免惡意的裝置或驅動程式</li>
    </ul>
  </li>
  <li>DDIO (Data Direct I/O)
    <ul>
      <li>在某些 Intel 平台上，DMA 的傳輸可以跳過 DRAM 直接傳輸到 cache，例如: Xeon, DDIO</li>
      <li>例如 ARM 上的 ACP(Access to Shared Caches)，即使用 DMA 對這個裝置進行操作，
其內容也會被同步到 cache memory 裡面，包括 L1 和 L2 cache</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Access to Shared Caches vs. Traditional methods</p>
</blockquote>

<p><img src="/image/2023/09-12-operating_system_introduction/7.png" alt="" height="100%" width="100%" /></p>

<h3 id="io-subsystem-notify-the-cpu">I/O Subsystem notify the CPU</h3>

<p><a href="./2023-09-12-operating_system_introduction.html#117-interrupt-hardware-concept">1.17 Interrupt hardware concept</a><br />
<a href="./2023-09-12-operating_system_introduction.html#120-interrupt-vector-table">1.20 Interrupt vector table</a><br />
<a href="./2023-09-12-operating_system_introduction.html#121-interrupt-service-routine">1.21 Interrupt Service Routine</a><br />
<a href="./2023-09-12-operating_system_introduction.html#122-bottom-half">1.22 Bottom half</a><br />
<a href="./2023-09-12-operating_system_introduction.html#123-bottom-half-and-top-half">1.23 Bottom half and Top half</a><br />
<a href="./2023-09-12-operating_system_introduction.html#124-polling">1.24 Polling</a><br />
<a href="./2023-09-12-operating_system_introduction.html#125-buffering">1.25 Buffering</a></p>

<p>OS 交付工作給周邊裝置後，於工作完成後通知 CPU 的方法可以使用:</p>
<ul>
  <li>Interrupt</li>
  <li>Polling</li>
  <li>Interrupt + Polling</li>
</ul>

<h5 id="117-interrupt-hardware-concept">1.17 Interrupt hardware concept</h5>

<p>Interrupt 是一種改變程式正常執行流程的機制，可以由 Device 或者 CPU 本身產生</p>

<ul>
  <li>Legacy Interrupt
    <ul>
      <li>由實體線路構成，每個裝置連接到實體的中斷線，中斷線連接到 Programmable interrupt controller(PIC, 可程式化中斷控制器)，PCI 再向 CPU 的 INT 腳位發出中斷訊號</li>
      <li>PC 中斷線也就共 15 條，但是 Device 通常不只 15 個，因此必須數個裝置共用一條中斷線</li>
    </ul>
  </li>
  <li>Message Signaled Interrupts
    <ul>
      <li>所有 Devices 共用一組中斷線路，裝置在中斷線路上寫入自己的中斷編號，就會觸發 CPU 中斷</li>
      <li>這樣就類似在一條線上傳輸編碼，經過解碼器後推向 CPU，讓 CPU 對自己送出中斷，例如: PCI 的 MSI-X 支援 2048 個中斷編號</li>
    </ul>
  </li>
</ul>

<p><img src="/image/2023/09-12-operating_system_introduction/8.png" alt="" height="100%" width="100%" /></p>

<blockquote>
  <p>CPU 會設計好 IVT 的位置，由 OS 放入適當的 ISR 這部分也是驅動程式(Device Drver) 的一部分</p>
</blockquote>

<h5 id="120-interrupt-vector-table">1.20 Interrupt vector table</h5>

<ul>
  <li>Interrupt 處理流程:
    <ol>
      <li>Interrupt Request: 當中斷請求發生時，將所有中斷 Disable，將 CPU 切換到 Kernel mode</li>
      <li>Store State: 暫停目前的 Process 並保存此 Process 的執行狀況</li>
      <li>Interrupt Vector Table: OS 根據 Interrupt ID 查詢 IVT，並取得 Interrupt Service Routine 的開始位置</li>
      <li>Interrupt Service Routine: 執行 ISR</li>
      <li>Restore State: 恢復之前 Process 的執行狀況
        <ul>
          <li>這時候不一定恢復原本的 Process，因為 System call 可能改變 Process 的狀態，由 Scheduler 來決定下一個執行的 Process(不一定是原本的 Process)</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<p><img src="/image/2023/09-12-operating_system_introduction/9.png" alt="" height="100%" width="100%" /></p>

<ul>
  <li>IVT 放置的是 ISR 的開始位置
    <ul>
      <li>ISR 開頭都是用組語寫的，如果 C 的執行環境設定好也可以用 C</li>
    </ul>
  </li>
</ul>

<h5 id="121-interrupt-service-routine">1.21 Interrupt Service Routine</h5>

<p>發生 Interrupt 時是 Disable Interrupt，但在 ISR 的時候可以視情況決定是否要 Enable Interrupt，要允許哪寫 Interrupt，如果再 ISR 中 Enable interrupt 表示允許巢狀中斷(Nested Interrupt)</p>

<ul>
  <li>Nested Interrupt: 「一個中斷，被另一個中斷給中斷」</li>
</ul>

<p>Linux 中，ISR 只處理必須立即處理的部分，剩餘的部分交由 Kernel thread 處理。例如: ksoftirqd</p>

<ul>
  <li>ISR 中不能呼叫任何會造成「wait」的函數，例如: semaphore 中的 <code class="language-plaintext highlighter-rouge">wait()</code>
    <ul>
      <li>從設計上 <code class="language-plaintext highlighter-rouge">wait()</code> 的主體是 task (can context swtich)，ISR 只是一個有自己堆疊的函數，不是 task</li>
      <li>從邏輯上 ISR 是處理 I/O 中的「必要部分」(緊急性)，因此不應該 <code class="language-plaintext highlighter-rouge">wait()</code></li>
      <li>如果程式邏輯上必須要 <code class="language-plaintext highlighter-rouge">wait()</code>，就要考慮是否把這部分留給 Bottom half 解決</li>
    </ul>
  </li>
</ul>

<h5 id="122-bottom-half">1.22 Bottom half</h5>

<p>Bottom half 可以分為三種 softirq, tasklet, work-queue</p>
<ul>
  <li><strong>Softirq</strong> 可以在多個 CPU 上平行運行，必須在編譯時靜態註冊</li>
  <li><strong>Tasklet</strong> 是建立在 softirq 之上的一種機制，tasklet 可以動態註冊和銷毀，相同類型的 tasklet 不能在多個 CPU 上同時運行</li>
  <li><strong>Work-queue</strong> 是一種完全不同的機制，work-queue 可以確保同一種類型的 driver 只會在同一個 CPU 上運行
從效能高低上是從左往右排序，從易寫程度上是從右往左排序</li>
</ul>

<p><img src="/image/2023/09-12-operating_system_introduction/10.png" alt="" height="100%" width="100%" /></p>

<ul>
  <li>理論上這三個都應該由 Kernel thread 來呼叫
    <ul>
      <li>如果是 Kernel thread(task) 那就可以 wait()</li>
    </ul>
  </li>
  <li>實際上 softirq, tasklet 在 Linux kernel 可以由 Linux kernel 提供的一小段程式碼在 ISR 結束時呼叫
    <ul>
      <li>這樣的話他是執行在 ISR 中，這樣是不能 wait()</li>
    </ul>
  </li>
</ul>

<p>會設計成 ISR 也可以呼叫的原因是，如果這次 ISR Loading 並不重的時候就乾脆全部的工作都在 ISR 完成，這樣的消耗會比呼叫 Kernel thread 更少</p>

<p>在 <a href="./2023-09-12-operating_system_introduction.html#driver-architecture">Driver Architecture</a> 篇章會更詳細的說明</p>

<blockquote>
  <p>ksoftirqd 最多寫 32 個驅動程式在裡面，只有高速裝置會掛在 ksoftirqd 例如: Network Card</p>
</blockquote>

<blockquote>
  <p>延伸閱讀: <a href="https://stackoverflow.com/questions/7137209/difference-between-softirqs-and-tasklets">Difference between SoftIRQs and Tasklets</a>, <a href="https://stackoverflow.com/questions/14982589/tasklet-taskqueue-work-queue-which-to-use">tasklet, taskqueue, work-queue – which to use?</a></p>
</blockquote>

<h5 id="123-bottom-half-and-top-half">1.23 Bottom half and Top half</h5>

<blockquote>
  <p>Bottom half 的 softirq 每個 Core 就只有一個 <code class="language-plaintext highlighter-rouge">ps -e | grep softirq</code></p>
</blockquote>

<p>在這裡 Top half, Bottom half 分別指的是:</p>
<ul>
  <li><strong>Top half</strong>: 是指來立刻響應的 Interrupt 時處理的中斷函數，在這個階段執行快速且必要的硬體操作，如: 保存狀態，和呼叫 Bottom half</li>
  <li><strong>Bottom half</strong>: 跟 Top half 的區別是執行期間 Interrupt 是啟用的</li>
</ul>

<p>這裡進入 Bottom half 的工作會被包裝成一個 Struct 兩個 Pointer，包含 Function, Data，然後將這個 Struct 加入一個 Linked list，
之後等待 CPU 有空閒時 softirq 會從中取出 Struct 來執行 Bottom half。</p>

<ul>
  <li><strong>Function pointer</strong>: 該函數定義了 Bottom half 實際的執行工作，包含: 處理資料，啟動另一個 I/O 等等</li>
  <li><strong>Data pointer</strong>: 指向工作相關的資料，硬體的資料，要計算的參數，需要修改的 Memory 等等</li>
</ul>

<p>在 Linux 中，當 top half 決定將一些工作推遲到 bottom half 時，這些工作會被包裝成一個結構，該結構包含兩個指標：一個函數指標和一個資料指標¹。</p>

<h5 id="124-polling">1.24 Polling</h5>

<blockquote>
  <p>如果系統的 Loading 很輕，並且系統請求的時間比較沒規則時 Interrupt 會比較好，但如果負載高 Interrupt 被不斷的送出，
這樣可能會導致 CPU 不斷的去處理 Interrupt，此時 Polling 會比較好</p>
</blockquote>

<ul>
  <li>與 Interrupt 不同，Polling 是 OS 每隔一段時間主動去探詢裝置的狀態</li>
  <li>如果數個 Device 共用同一條 Interrupt 那麼當 Interrupt 發生時，OS 必須</li>
  <li>某些裝置同時支援 Interrupt 和 Polling，例如: Network Card，可以在負載量高/低時做切換</li>
</ul>

<blockquote>
  <p>像滑鼠跟鍵盤就通常是採用 Polling，除非有特殊需求，例如: 電競滑鼠</p>
</blockquote>

<h5 id="125-buffering-and-kernel-bypass">1.25 Buffering and Kernel bypass</h5>

<ol>
  <li>read(fd, buf, 200) 會用掉四個 Register
    <ul>
      <li>read(): 本身就是參數(No. 3 Interrupt, $AX 要設定為 3)</li>
      <li>fd: 從哪裡讀資料</li>
      <li>buf: buffer 的起始位置，200 Buffer size</li>
    </ul>
  </li>
  <li>read 呼叫後 Kernel 會配置 krl_buf，DMA 傳輸會將資料從 dsk_buf 搬移到 krl_buk</li>
  <li>最後由 Kernel 將資料 Copy 到 Userspace</li>
</ol>

<p><img src="/image/2023/09-12-operating_system_introduction/11.png" alt="" height="100%" width="100%" /></p>

<ul>
  <li><strong>Kernel bypass</strong>: 是指不需要透過 Linux kernel 的功能，使用自己實現的相同功能的程式碼直接將 Device 的資料 Copy 到 Userspace
    <ul>
      <li>這可以幫助解決在高 concurrent 下由於 Interrupt Handling, Memory Copy, Context switch, Locality miss, 
CPU Affinity, Memory Management 所造成的性能瓶頸</li>
      <li>代表的技術有 DPDK, eBPF 等等</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>延伸閱讀: <a href="https://zhuanlan.zhihu.com/p/630976564">kernel-bypass 内核旁路技术介绍</a></p>
</blockquote>

<h3 id="scheduler-and-file-system">Scheduler and File System</h3>

<h5 id="126-process-and-thread-of-linux">1.26 Process and Thread of Linux</h5>

<ul>
  <li>在 Linux 提供下列 System call
    <ul>
      <li>fork(), vfork() 產生 Process</li>
      <li>clone() 產生 Task(Process, Thread)</li>
      <li>execve() 將一個執行檔內的程式載入該 Task 中</li>
    </ul>
  </li>
  <li>對 Linux 來講 Process, Thread 都是 Task
    <ul>
      <li>Linux 使用 Task struct 來描訴 Process, Thread</li>
      <li>Process, Thread 的差異只是「共享資源的多寡」，尤其是記憶體是否共用</li>
      <li>fork, vfork, clone 都是呼叫 Kernel 中的 do_fork</li>
    </ul>
  </li>
  <li>有一些 Thread 只執行於 Kernel mode，Linux 稱為 Kernel thread</li>
</ul>

<h5 id="127-scheduler">1.27 Scheduler</h5>

<blockquote>
  <p>如果只說 Scheduler 通常指的是 CPU Scheduler</p>
</blockquote>

<ul>
  <li>傳統上 Scheduler 希望達成以下目標
    <ul>
      <li>依照優先權賦予優先權的公平性</li>
      <li>所有的 Task 都可以在合理的時間內，再次獲得 CPU 使用權</li>
      <li>優化 I/O 效能，例如: 處理 I/O 的設備可以先執行，接下來工作交給 I/O 設備</li>
    </ul>
  </li>
  <li>Linux 更進一步的達到以下目標
    <ul>
      <li>Multi-core 上能做到 Load balance</li>
      <li>Scheduler 本身不至於造成 Multi-core 的效能瓶頸</li>
      <li>對多媒體、遊戲有更好的支援，CFS</li>
    </ul>
  </li>
  <li>Linux 還未達到的目標
    <ul>
      <li>Real-time system 的支援</li>
      <li>Linux 在手機上的 Scheduler 比 iOS 的 Scheduler 更耗電(iOS 並不是真正的多工 OS)</li>
    </ul>
  </li>
</ul>

<h5 id="128-file-system">1.28 File system</h5>

<blockquote>
  <p>在檔案系統要注意到這些: 新技術如： SSD、管理的問題(大檔案、零碎檔案)、存取行為(循序/隨機存取)、檔案的重複性問題、混合硬碟(SSD\HDD)</p>
</blockquote>

<ul>
  <li>Linux 使用 Virtual file system(VFS), 兼容多種檔案系統，大部分這些檔案系統都使用「<strong><a href="https://en.m.wikipedia.org/wiki/Inode">i-node</a></strong>」的概念描述檔案
    <ul>
      <li><strong><a href="https://en.m.wikipedia.org/wiki/Inode">i-node</a></strong>: 用於描述檔案或目錄，裡面儲存資料的屬性和位置，例如: 所有者、許可權、大小、最後修改時間等</li>
      <li><strong><a href="https://en.m.wikipedia.org/wiki/Virtual_file_system">VFS</a></strong>: 透過統一的介面，使無論底層的檔案系統是什麼，都能透過介面處理，例如: open(), read(), write()</li>
      <li><strong><a href="https://en.m.wikipedia.org/wiki/File_system">File system</a></strong>: 用於管理底層裝置資料存取的機制，例如: ext4, NTFS, FAT32 …</li>
    </ul>
  </li>
  <li>Linux 官方的 File system 是 ext4’
    <ul>
      <li><strong>ext4</strong>： 是 Journaling file system，因此當發生意外，檔案系統不至於完全損毀，並且能快速恢復(fsck.ext4)</li>
    </ul>
  </li>
  <li>Linux 支援 <strong><a href="https://zh.m.wikipedia.org/zh-tw/Btrfs">btrfs</a></strong>，btrfs 借用了 zfs 的很多概念，主要包括:
    <ul>
      <li>snapshot, copy-no-write, hot plugging HDD/SSD, difference disk load balance, backup support</li>
    </ul>
  </li>
</ul>

<h3 id="hardware-progress">Hardware progress</h3>

<p><a href="./2023-09-12-operating_system_introduction.html#129-smp-and-cmp">1.29 SMP and CMP</a><br />
<a href="./2023-09-12-operating_system_introduction.html#130-single-isa-heterogeneous-multi-core">1.30 Single-ISA heterogeneous multi-core</a><br />
<a href="./2023-09-12-operating_system_introduction.html#131-uma-and-numa">1.31 UMA and NUMA</a></p>

<ul>
  <li>目前已經很難提升 CPU 的 Clock
    <ul>
      <li>相同架構下，提升 Clock 是最直接方式來的提升 Performance</li>
      <li>提高 Clock 會遇到大量的熱，也是提升效能的瓶頸</li>
    </ul>
  </li>
  <li>Processor, Menory, Storage 等等藉由不斷的「複製，貼上」產生平行運作
    <ul>
      <li>平行運作往往需要軟硬體結合</li>
      <li>很多時候，硬體提供「多種選擇」給軟體進行優化</li>
    </ul>
  </li>
</ul>

<p><img src="/image/2023/09-12-operating_system_introduction/14.png" alt="" height="100%" width="100%" /></p>

<blockquote>
  <p>寫平行化程式，程式碼每年可以有 23% 的效能提升，否則只有 4.6%</p>
</blockquote>

<p>平行處理架構指的是「同時使用多個 Process(Core)」例如: PC 常見的 Multi-Core Process
<strong>他的優點</strong>:</p>
<ul>
  <li>提高產能: 在工作可以平行化時，產能將以倍數提升</li>
  <li>成本考量: 相較於高時脈的 Processor，工作平行化後，數個時脈低的 Processor 能得到一樣的效果</li>
  <li>增加可靠度: 高階伺服器可以提供 Processor, Memory 熱插拔的功能，例如: Linux, 可以在不停機的情況下更換 CPU</li>
</ul>

<h5 id="129-smp-and-cmp">1.29 SMP and CMP</h5>

<ul>
  <li><em><a href="https://en.m.wikipedia.org/wiki/Symmetric_multiprocessing">Symmetirc multiprocessor</a></em>(SMP, 對稱多處理)
    <ul>
      <li>每個 Processor 的地位是等價的，應用程式可以在這些處理器上做轉移(migration)</li>
      <li>在這個架構上所有 Processor 都共享一個共同的 Main memory，有可能會導致記憶體存取衝突而影響效能</li>
    </ul>
  </li>
  <li><em><a href="https://en.m.wikipedia.org/wiki/Multi-core_processor">Chip multiprocessor</a></em>(CMP, 單晶片多處理) 也稱作 <strong>Multi-core</strong>
    <ul>
      <li>將多顆 (Core)Processor 集成至一顆晶片</li>
      <li>每個 Core 都有自己的 Cache 可以減少對共用 Memory 的存取需求</li>
      <li>共享最下層的 Last level cache(LLC)，因此不同 Core 之間的轉移比較快速</li>
    </ul>
  </li>
  <li><em><a href="https://en.m.wikipedia.org/wiki/Simultaneous_multithreading">Simultaneous multithreading</a></em>(SMT, 同步多執行緒)
    <ul>
      <li>在一顆 Processor 上用硬體模擬出 N 顆 Process，硬體的主要成本是 Logical register 數量增加 N 倍</li>
      <li>能更有效的利用 Processor 內部的 Function unit，如: 加法器，乘法器等</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Intel 宣稱他們實現的 SMT(Hyper-threading) 增加 5% 的晶片面積，可以獲得 15% ~ 30% 的效能提升<br />
AMD 於 2017 推出的 Zen CPU 也實現了 SMT</p>
</blockquote>

<p><img src="/image/2023/09-12-operating_system_introduction/12.png" alt="" height="100%" width="100%" /></p>

<blockquote class="block-warning">
  <p>上方右圖有兩個 Instruction flow(Register set) 去競爭資源，例如: Floating point unit, Adder, Loader, Storer<br />
SMT 不是去增加系統的速度，是增加系統的使用率，前提是有足夠的 Task 跟進行的運算可以 <a href="https://en.m.wikipedia.org/wiki/Loop_unrolling">Loop unrolling</a>，<br />
例如: Fibonacci 因為每次都必須算出前一個數字才能繼續後面數字的運算</p>
</blockquote>

<blockquote>
  <p>延伸閱讀: <a href="https://stackoverflow.com/questions/8171141/algorithm-efficiency-is-partially-unrolling-a-loop-effective-if-it-requires-mo">Algorithm Efficiency - Is partially unrolling a loop effective if it requires more comparisons?</a></p>
</blockquote>

<h6 id="130-single-isa-heterogeneous-multi-core">1.30 Single-ISA heterogeneous multi-core</h6>

<ul>
  <li>在學術上是多個處理器，這些處理器使用同樣的指令集，但是處理器的內部設計(Micro-Architecture)不同
    <ul>
      <li>例如: Clock，Pipeline depth，Funciont unit number</li>
      <li>有些程式指令平行度高，適合 Pipeline、Superscalar</li>
      <li>有些程式指令平行度低，適合 In-order issue、High clock processor</li>
      <li>因 Instruction set 相同，OS 可以幫合適的 Task 挑選適合的 Processor</li>
    </ul>
  </li>
  <li>ARM 上實現的 Big-Little 架構是上述的一個實現
    <ul>
      <li>雖然 Processor 運算速度不同，但其 Instruction set 相容</li>
      <li>OS 可以依照需求使用高效能 Processor(Big) 或省電型 Processor(Little)</li>
    </ul>
  </li>
</ul>

<p><img src="/image/2023/09-12-operating_system_introduction/13.png" alt="" height="100%" width="100%" /></p>

<blockquote>
  <p>在 Big.Little 中可以做 Task migration，這部分是 OS 跟 Programmer 需要去考慮的</p>
</blockquote>

<ul>
  <li>SMT 是由 DM Tullsen, SJ Eggers, HM Levy 所提出
    <ul>
      <li>Simultaneous multithreading: Maximizing on-chip parallelism, ISCA, 1995.</li>
      <li>Intel 於 2002 實現這個構想，並將它稱之為 hyperthreading</li>
    </ul>
  </li>
  <li>Big.LITTLE 的概念由 R Kumar, KI Farkas, NP Jouppi, P Ranganathan, DM Tullsen 提出
    <ul>
      <li>Single-ISA heterogeneous multi-core architectures: The potential for processor power reduction, MICRO, 2003.</li>
    </ul>
  </li>
  <li>更厲害的是：這二個架構的創想來自於同一個實驗室
    <ul>
      <li>https://cseweb.ucsd.edu/~tullsen/</li>
    </ul>
  </li>
</ul>

<h5 id="132-uma-and-numa">1.32 UMA and NUMA</h5>

<ul>
  <li>目前為止(2018)所使用的 Processor memory architecture 大部分為 <strong><a href="https://en.m.wikipedia.org/wiki/Uniform_memory_access">Uniform memory access</a></strong>(UMA)
    <ul>
      <li>大致上可以說: 每個 Processor 存取任何位置的 Memory 的速度都是相等的</li>
      <li>UMA 架構使用一套記憶體插槽，也就是共享 Memory bus</li>
      <li>對於 UMA Processor 而言，當 Processor 增加時，記憶體頻寬是效能瓶頸所在(Intel core i9 是有 18C36T 的 UMA Processor)</li>
    </ul>
  </li>
  <li><strong><a href="https://en.m.wikipedia.org/wiki/Non-uniform_memory_access">Non-Uniform memory access</a></strong>(NUMA)
    <ul>
      <li>傳統上是插兩個以上的 CPU，如部分機架式伺服器: HP DL380 Gen7</li>
      <li>AMD 的 threadripper 將兩顆 CPU 封裝在一起，threadripper 上可以看到兩個 DRAM 插槽</li>
      <li>對 NUMA 來說記憶體分為 Local, Remote，存取 Local 時的速度會較快</li>
    </ul>
  </li>
</ul>

<p><img src="/image/2023/09-12-operating_system_introduction/15.png" alt="" height="100%" width="100%" /></p>

<p><img src="/image/2023/09-12-operating_system_introduction/16.png" alt="" height="100%" width="100%" /></p>

<blockquote>
  <p>這樣的做法兩邊都會有獨立控制的 Memory bus，避免了部分的記憶體頻寬的效能瓶頸</p>
</blockquote>

<h3 id="driver-architecture">Driver Architecture</h3>

<p>Driver 中可延遲處理(Bottom half) 的形式就分成三種，這部分在 <a href="./2023-09-12-operating_system_introduction.html#122-bottom-half">Bottom half</a> 簡單提過:</p>

<ul>
  <li>softirq(軟中斷)
    <ul>
      <li>softirq 支援 SMP，同一個 softirq 可以在不同的 CPU 上同時運行，softirq 必須是 <strong><a href="https://en.m.wikipedia.org/wiki/Reentrancy_%2528computing%2529">Reentrancy</a></strong>(可重入的)</li>
      <li>softirq 是在編譯期間靜態註冊，不像 tasklet 那樣能被動態註冊或去除</li>
      <li>HI_SOFTIRQ, TIMER_SOFTIRQ, NET_TX_SOFTIRQ, NET_RX_SOFTIRQ, SCSI_SOFTIRQ, TASKLET_SOFTIRQ</li>
      <li>基本原則是使用在高速裝置或該裝置不能被延遲，如: Network RX/TX, Timer inputerret, Disk, <strong>tasklet</strong></li>
    </ul>
  </li>
</ul>

<p>softirq 在 Kernel 編譯是就已經定義、註冊好，通常是不會去做改寫。會使用 softirq 的原因主要是因為發現 I/O 的效能瓶頸是在 CPU，
前提是要有足夠的 Processor。</p>

<ul>
  <li>tasklet
    <ul>
      <li>tasklet 不允許兩個相同類型的 tasklet 同時執行，即使在兩個</li>
    </ul>
  </li>
  <li>work-queue
    <ul>
      <li>由 Kernel theard 來實現，所以可以被 context switch(前兩種只能被 ISR 打斷)</li>
      <li>適合需要長時間執行，或需要 seelp</li>
      <li>默認可以被 Interrupt，不持有任何 Locked</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>延伸閱讀: <a href="https://embetronicx.com/tutorials/linux/device-drivers/softirq-in-linux-kernel/">V-Softirq in Linux Device Driver – Linux Device Driver Tutorial</a>, <a href="https://zhuanlan.zhihu.com/p/361409809">Linux softirq, tasklet, workqueue</a></p>
</blockquote>

<p><strong>下面是 Interrupt 離開時觸發 softirq 的流程與程式碼</strong>:</p>

<p><img src="/image/2023/09-12-operating_system_introduction/17.png" alt="" height="75%" width="75%" /></p>

<p>ksoftirq 是在 Kernel thread 會去呼叫 Loop，這個 Loop 會不斷去拿工作來做，這個 Loop 可以被 ISR 或 ksoftirqd 呼叫，
如果是由 ksoftirqd 呼叫那就可以 sleep，但如果是由 ISR 呼叫 Loop 則是執行在 Interrupt context 那就不能 sleep。</p>
<ul>
  <li>會設計 ISR 可以呼叫 Loop 的原因是 Linux 為了優化，如果 Interrupt 所觸發的工作並不多，就乾脆在 ISR 中處理完</li>
  <li>若是由 ksoftirq 呼叫就會讓 Interrupt 先結束，後續讓 Scheduler 來安排 Task 進行工作</li>
</ul>

<p><img src="/image/2023/09-12-operating_system_introduction/18.png" alt="" height="75%" width="75%" /></p>

<p><img src="/image/2023/09-12-operating_system_introduction/19.png" alt="" height="75%" width="75%" /></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">invoke_softirq()</code> 會去 Loop 中拿取工作來執行
    <ul>
      <li><code class="language-plaintext highlighter-rouge">force_irqthreads</code> 用這個變數來判別是 Interrupt context 呼叫還是 Kernel thread</li>
      <li><code class="language-plaintext highlighter-rouge">__do_softirq()</code>, <code class="language-plaintext highlighter-rouge">do_softirq_own_stack()</code> 都是去執行 softirq，差異在 IRQ STACK 詳細可見延伸閱讀</li>
      <li><code class="language-plaintext highlighter-rouge">wakeup_softirqd()</code> 則是叫醒 ksoftirqd 把剩下的工作交給 ksoftirqd 來排程</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>延伸閱讀: <a href="http://www.wowotech.net/irq_subsystem/soft-irq.html">Linux kernel的中断子系统 softirq</a></p>
</blockquote>

<p><strong>相較於 softirq, work-queue 的流程單純很多，不會運行在 Interrupt context:</strong></p>

<p><img src="/image/2023/09-12-operating_system_introduction/20.png" alt="" height="75%" width="75%" /></p>

<p><strong>General rules for driver writing</strong></p>

<p>共用的資料跟誰共用，雙方是否會同時執行:</p>
<ul>
  <li>會: 就要使用 spinlock(Mulit-Processor)、semaphore(Signle-Processor)</li>
  <li>不會，那要注意是否會 Preempt:
    <ul>
      <li>誰會 Preemmpt 誰</li>
      <li>如果單一方向如 A Preempt B，B 去 Disable A 就不會有 Rest condition，例如: Scheduler, Local IRQ, Bottom half</li>
      <li>如果是雙向的 Preempt 那就是會同時執行</li>
    </ul>
  </li>
  <li>要很清楚程式中隱藏的意思
    <ul>
      <li>例如: malloc 是否會造成 Context switch, write 會做 I/O 動作會不會 Context switch</li>
    </ul>
  </li>
</ul>

<h3 id="start-the-os">Start the OS</h3>

<h5 id="133-start-the-os">1.33 Start the OS</h5>

<blockquote>
  <p>為什麼不能直接從 Disk 啟動 OS，這是因為 Disk 也需要 Driver 來啟動</p>
</blockquote>

<ul>
  <li>CPU 能直接控制 DARM, ROM 是因為這兩者都是 Byte address
    <ul>
      <li>CPU 只要在 Address bus 上放入要讀取的資料的 Address 就能從 Data bus 上讀取想要的資料</li>
    </ul>
  </li>
  <li>Disk 屬於 Block device 需要下達命令告訴 Disk 需要第幾個 Block，之後 Disk 再講 Block 寫到軟體指定的位置，如： (ATA-8, <a href="https://en.m.wikipedia.org/wiki/ATAPI">ATAPI</a>)</li>
</ul>

<p>如果沒有軟體驅動的情況下 CPU 無法直接讀取 Disk，因此需要在 PC 架構中在 Boot rom 中放入「BIOS」，
BIOS 的重要目的就是讀取 Disk 上的 <a href="https://www.lifewire.com/what-is-a-boot-sector-2625815">Boot sector</a>。</p>

<p><img src="/image/2023/09-12-operating_system_introduction/21.png" alt="" height="50%" width="50%" /></p>

<p><strong>Bootstrap</strong></p>

<ol>
  <li>BIOS(ROM) 讀取 Boot sector(通常是 Disk 上的第 0 個 Block)</li>
  <li>BIOS 會帶起來的是 GRUB(Boot loader)，現在也可以從 BIOS 使用 UEFI(BIOS 也認得 OS)</li>
  <li>如果帶起的 OS 是 Linux 那麼就必須把開機相關的檔案放在 /boot 下，並且 GRUB 認得該目錄使用的檔案系統</li>
  <li>Linux kernel 先掃描裝置狀態，根據裝置狀態配置記憶體(Virtual memory layout)，之後再啟動 Cache
    <ul>
      <li>先設定 Virtual memory 是因為這裡必須將映射到 I/O 的部分設定為 Non-cached</li>
    </ul>
  </li>
  <li>Linux kernel 啟動後，啟動第一個 User space 的程式，傳統上是 init，也有許多 Linux 改用 systemd，他們的 pid 都是 1，
負責 Linux 後續的初始化</li>
</ol>

<blockquote>
  <p>這裡是因為對應 I/O 的區段(例如: DMA)，不希望這些操作被 Cache，如果被 Cache 可能會導致資料不一致，因此要先設定 Non-cached</p>
</blockquote>

<p><strong>BIOS limitations</strong></p>

<ul>
  <li>BIOS 必須要認得 Disk 上的開機 Block，如果 BIOS 不支援該 Disk，將無法啟動 OS(例如: 容量超過 BIOS 的定址範圍)</li>
  <li>BIOS 內含多種驅動程式，例如要支援 USB
    <ul>
      <li>大部分 BIOS 不支援藍芽裝置，因此開機時的藍芽滑鼠，鍵盤等等都不能與 BIOS 互動</li>
    </ul>
  </li>
</ul>

<blockquote class="block-warning">
  <h5 id="last-edit">Last Edit</h5>
  <p>10-09-2023 18:27</p>
</blockquote>

</section>
            </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div></div>
        <div class="normal">
            <section class="normal">
                
                <i class="fa fa-eye"></i>
                <span id="page-hit-tracker"></span>, 
                <i class="fa fa-archive"></i>
                
                OS
                
                
            </section>
        </div>
    </div>
<script async src="https://www2.cs.ccu.edu.tw/~xbs112m/tracker.php"></script>
</div>

<!-- introduce mathjax support -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script
  type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>


<!-- introduce per-page mermaid support -->


<!-- introduce mathjax support -->
<script>
    function fixes_chrome_anchors() {
        let chrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
        if (window.location.hash && chrome) {
            setTimeout(function () {
                var hash = window.location.hash;
                window.location.hash = "";
                window.location.hash = hash;
            }, 300);
        }
    }

    if (document.readyState === "loading") {
        // Loading hasn't finished yet
        document.addEventListener("DOMContentLoaded", fixes_chrome_anchors);
    } else {
        // `DOMContentLoaded` has already fired
        fixes_chrome_anchors();
    }
</script>

<!-- customize line 38-50 swap next previous-->
                    
                        <a href="/jekyll/2023-09-20-compiler_introduction.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: Paper | Test Case Generation Based on Constraint Logic Graph">
                            <i class="fa fa-angle-left"></i>
                        </a>
                    

                    
                        <a href="/jekyll/2023-09-07-test_case_generation_based_on_constraint_logic_graph.html" class="navigation navigation-next navigation-unique" aria-label="Next page: Compiler | Compilers Introduction">
                            <i class="fa fa-angle-right"></i>
                        </a>
                    
                </div>
            </div>

            <script>
            var gitbook = gitbook || [];
            gitbook.push(function() {
                gitbook.page.hasChanged({
    "page": {
        "title": "Introduction",
        "level": "1.1",
        "depth": 1,
        
        "next": {
            "title": "Compiler | Compilers Introduction",
            "level": "1.2",
            "depth": 1,
            "path": "_posts/2023/2023-09-20-compiler_introduction.md",
            "ref": "_posts/2023/2023-09-20-compiler_introduction.md",
            "articles": []
        },
        
        "dir": "ltr"
    },    "config": {
        "plugins": ["fontsettings", "highlight", "livereload", "lunr", "search", "sharing", "theme-default", "livereload"],
        "styles": {
            "ebook": "styles/ebook.css",
            "epub": "styles/epub.css",
            "mobi": "styles/mobi.css",
            "pdf": "styles/pdf.css",
            "print": "styles/print.css",
            "website": "styles/website.css"
        },
        "pluginsConfig": {
            "expandable-chapter-small2": {
                "articlesExpand": true,
            },
            "fontsettings": {
                "family": "sans",
                "size": 1,
                "theme": "white"
            },
            "highlight": {},
            "livereload": {},
            "lunr": {
                "ignoreSpecialCharacters": false,
                "maxIndexSize": 1000000
            },
            "search": {},            "sharing": {
                "facebook": false,

                "google": false,

                "github": true,
              
                "github_link": "https://github.com",
              

                "telegram": false,
                "telegram_link": "https://t.me",

                "instapaper": false,

                "twitter": false,
              

                "vk": false,

                "weibo": false,

                // "all": ["facebook", "google", "twitter", "weibo", "instapaper", "github", "telegram"]
            },
"theme-default": {
                "showLevel": false,
                "styles": {
                    "ebook": "styles/ebook.css",
                    "epub": "styles/epub.css",
                    "mobi": "styles/mobi.css",
                    "pdf": "styles/pdf.css",
                    "print": "styles/print.css",
                    "website": "styles/website.css"
                }
            },
        },
        "theme": "default",
        "author": "Tao He",
        "pdf": {
            "pageNumbers": true,
            "fontSize": 12,
            "fontFamily": "Arial",
            "paperSize": "a4",
            "chapterMark": "pagebreak",
            "pageBreaksBefore": "/",
            "margin": {
                "right": 62,
                "left": 62,
                "top": 56,
                "bottom": 56
            }
        },
        "structure": {
            "langs": "LANGS.md",
            "readme": "Home.md",
        },
        "variables": {},
        "title": "Home",
        "language": "en",
        "gitbook": "*"
    },
    "file": {
        "path": "_posts/2023/2023-09-12-operating_system_introduction.md",
        "mtime": "2023-09-12 00:00:00 +0000",
        "type": "markdown"
    },
    "gitbook": {
        "version": "3.2.3",
        "time": "2026-02-18 08:41:21 +0000"
    },
    "basePath": "",
    "book": {
        "language": ""
    }
});
            });
            </script>
        </div><script src="/assets/gitbook/gitbook.js"></script>
<script src="/assets/gitbook/theme.js"></script>

<script src="/assets/gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
<script src="/assets/gitbook/gitbook-plugin-copy-code-button/toggle.js"></script>
<script src="/assets/gitbook/gitbook-plugin-expandable-chapters-small2/expandable-chapters-small.js"></script>
<script src="/assets/gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="/assets/gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
<script src="/assets/gitbook/gitbook-plugin-search-pro/search.js"></script>
<script src="/assets/gitbook/gitbook-plugin-sharing/buttons.js"></script>
<script src="/assets/gitbook/gitbook-plugin-splitter/splitter.js"></script>

<!--
<script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
<script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
<script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
<script src="../gitbook/gitbook-plugin-search/search.js"></script>
-->

</body>
</html>