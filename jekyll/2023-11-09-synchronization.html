<!DOCTYPE HTML>
<html lang="en" >
    <head><meta charset="UTF-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="google-site-verification" content="MrJpPCJ8htzZlGpC1wo97QA1_XWns05Ez0LBsW3wj3I" /><title>OS | Synchronization (Unfinished) · Home</title><meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="description" content="Build Jekyll site with the GitBook style.
"><meta name="generator" content="Jekyll (using style of GitBook 3.2.3)"><meta name="author" content="Benson Hsu"><link rel="stylesheet" href="/assets/gitbook/style.css">
<link rel="stylesheet" href="/assets/gitbook/gitbook-plugin-back-to-top-button/plugin.css">
<link rel="stylesheet" href="/assets/gitbook/gitbook-plugin-expandable-chapters-small2/expandable-chapters-small.css">
<link rel="stylesheet" href="/assets/gitbook/gitbook-plugin-fontsettings/website.css">
<link rel="stylesheet" href="/assets/gitbook/gitbook-plugin-search-pro/search.css">
<link rel="stylesheet" href="/assets/gitbook/gitbook-plugin-splitter/splitter.css">

<link rel="stylesheet" href="/assets/gitbook/rouge/colorful.css">

<link rel="stylesheet" href="/assets/gitbook/custom.css">
<link rel="stylesheet" href="/assets/gitbook/custom-local.css">

<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/assets/gitbook/images/apple-touch-icon-precomposed-152.png">
<link rel="shortcut icon" href="/assets/gitbook/images/favicon.ico" type="image/x-icon">




            <link rel="prev" href="/jekyll/2023-10-28-method_level_function_unit_testing.html" />
        

        
            <link rel="next" href="/jekyll/2023-11-23-based_on_clp_testcases.html" />
        
    </head>
    <body>
        <div class="book"><div class="book-summary">
    <script type="text/javascript">
        // Fixes the page links scroll problem on both desktop and mobile browsers
        function pageScrollToTop(element) {
            // both mobile and non-mobile
            $('div.body-inner').animate({scrollTop: 0});
            $(element).parent().find('li>ul>li').removeClass('active');
            return true;  // propagate
        }
        // Fixes the anchor links scroll problem on mobile browsers
        function mobilePageScrollToAnchor(element) {
            $(element).closest('li.chapter').find('ul>li').removeClass('active');
            $(element).parent().addClass('active');
            if ($(document).width() <= 1240) {
                $('div.body-inner').animate({scrollTop: $($(element).attr('href')).get(0).offsetTop});
            }
            return true;
        }
    </script>

    <nav role="navigation">
        <div id="book-search-input" role="search">
            <input type="text" placeholder="Type to search" />
        </div>
        <div id="book-search-input-link" role="search">
            <a href="/assets/search.html">Click to Search</a>
        </div>
        <ul class="summary">
            
            <li class="chapter" data-level="1.1" data-path="">
            
                <a href="/" onclick="pageScrollToTop(this)">
                    Home
                </a>
            </li>

            <li class="divider"></li>

            
                <!-- <p>pages</p> -->
                
                    

                    

                    
                
            
                <!-- <p>posts</p> -->
                
                    

                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2026-02-05-swagger.html">
                        
                            <a href="/jekyll/2026-02-05-swagger.html" onclick="pageScrollToTop(this)">
                                Backend | Swagger
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2026-02-02-inversion_of_control.html">
                        
                            <a href="/jekyll/2026-02-02-inversion_of_control.html" onclick="pageScrollToTop(this)">
                                Pattern | Inversion of Control
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2026-01-29-the_12_factor_app.html">
                        
                            <a href="/jekyll/2026-01-29-the_12_factor_app.html" onclick="pageScrollToTop(this)">
                                Backend | The 12-Factor App
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2026-01-26-ACPI_States.html">
                        
                            <a href="/jekyll/2026-01-26-ACPI_States.html" onclick="pageScrollToTop(this)">
                                Note | ACPI States
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2026-01-24-BIOS_introduction.html">
                        
                            <a href="/jekyll/2026-01-24-BIOS_introduction.html" onclick="pageScrollToTop(this)">
                                Note | BIOS Introduction
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2026-01-17-I2C_introduction.html">
                        
                            <a href="/jekyll/2026-01-17-I2C_introduction.html" onclick="pageScrollToTop(this)">
                                Note | I2C Introduction
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-11-21-llvm_cpu0_create_backend.html">
                        
                            <a href="/jekyll/2025-11-21-llvm_cpu0_create_backend.html" onclick="pageScrollToTop(this)">
                                LLVM | CPU0 Create Backend Machine
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-11-20-tablegen_introduction.html">
                        
                            <a href="/jekyll/2025-11-20-tablegen_introduction.html" onclick="pageScrollToTop(this)">
                                LLVM | TableGen Introduction
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-11-14-computer_organization_pipeline_hazards.html">
                        
                            <a href="/jekyll/2025-11-14-computer_organization_pipeline_hazards.html" onclick="pageScrollToTop(this)">
                                Computer Organization | Pipelines Hazards
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-11-12-computer_organization_pipeline.html">
                        
                            <a href="/jekyll/2025-11-12-computer_organization_pipeline.html" onclick="pageScrollToTop(this)">
                                Computer Organization | Pipelines
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-09-21-Resource_Acquisition_Is_Initialization.html">
                        
                            <a href="/jekyll/2025-09-21-Resource_Acquisition_Is_Initialization.html" onclick="pageScrollToTop(this)">
                                C++ | Resource Acquisition Is Initialization (RAII)
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-09-13-Big_Number_Multiplication.html">
                        
                            <a href="/jekyll/2025-09-13-Big_Number_Multiplication.html" onclick="pageScrollToTop(this)">
                                Algorithm | Big Number Multiplication
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-08-09-how_do_cpp_compiler_gen_exe_file.html">
                        
                            <a href="/jekyll/2025-08-09-how_do_cpp_compiler_gen_exe_file.html" onclick="pageScrollToTop(this)">
                                C++ | How C++ Compiler Generates Executable File
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2025-03-21-fluent_interface.html">
                        
                            <a href="/jekyll/2025-03-21-fluent_interface.html" onclick="pageScrollToTop(this)">
                                Pattern | Fluent Interface
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2024-10-17-KLEE_symbolic_execution.html">
                        
                            <a href="/jekyll/2024-10-17-KLEE_symbolic_execution.html" onclick="pageScrollToTop(this)">
                                Paper | KLEE: Introducing Symbolic Execution
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2024-07-28-parallel_and_distributed_systems_introduction.html">
                        
                            <a href="/jekyll/2024-07-28-parallel_and_distributed_systems_introduction.html" onclick="pageScrollToTop(this)">
                                PDS | Introduction of Parallel and Distributed Systems
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2024-06-21-competitive_paging_algorithm.html">
                        
                            <a href="/jekylls/2024-06-21-competitive_paging_algorithm.html" onclick="pageScrollToTop(this)">
                                Algorithm | Competitive Paging Algorithm
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2024-06-09-arch_user_repository.html">
                        
                            <a href="/jekylls/2024-06-09-arch_user_repository.html" onclick="pageScrollToTop(this)">
                                Note | Arch User Repository
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2024-04-09-hirschbergs_algorithm.html">
                        
                            <a href="/jekylls/2024-04-09-hirschbergs_algorithm.html" onclick="pageScrollToTop(this)">
                                Algorithm | Hirschberg&#39;s Algorithm
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2024-03-08-ANTLR_guide.html">
                        
                            <a href="/jekylls/2024-03-08-ANTLR_guide.html" onclick="pageScrollToTop(this)">
                                Compiler | ANTLR Guide
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2024-03-06-arch_linux_installation.html">
                        
                            <a href="/jekylls/2024-03-06-arch_linux_installation.html" onclick="pageScrollToTop(this)">
                                Note | Arch Linux Installation
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2024-03-01-maven_multi_module_project.html">
                        
                            <a href="/jekylls/2024-03-01-maven_multi_module_project.html" onclick="pageScrollToTop(this)">
                                Note | Apache Maven Multi-Module Project Guide
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2024-02-03-storage_and_file_system.html">
                        
                            <a href="/jekyll/2024-02-03-storage_and_file_system.html" onclick="pageScrollToTop(this)">
                                OS | Storage and File System
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2024-01-05-debian_btrfs.html">
                        
                            <a href="/jekylls/2024-01-05-debian_btrfs.html" onclick="pageScrollToTop(this)">
                                Note | Using btrfs on Debian
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2023-12-26-code_generation.html">
                        
                            <a href="/jekylls/2023-12-26-code_generation.html" onclick="pageScrollToTop(this)">
                                Compiler | Code Generation (Unfinished)
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-12-23-virtual_memory.html">
                        
                            <a href="/jekyll/2023-12-23-virtual_memory.html" onclick="pageScrollToTop(this)">
                                OS | Virtual Memory
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-12-20-system_testing.html">
                        
                            <a href="/jekyll/2023-12-20-system_testing.html" onclick="pageScrollToTop(this)">
                                Testing | System Testing
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-12-12-mutation_testing.html">
                        
                            <a href="/jekyll/2023-12-12-mutation_testing.html" onclick="pageScrollToTop(this)">
                                Testing | Mutation Testing
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-12-10-main_memory.html">
                        
                            <a href="/jekyll/2023-12-10-main_memory.html" onclick="pageScrollToTop(this)">
                                OS | Main Memory
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-12-09-class_level_testing.html">
                        
                            <a href="/jekyll/2023-12-09-class_level_testing.html" onclick="pageScrollToTop(this)">
                                Testing | Class-Level Unit Testing
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2023-11-29-semantic_analysis.html">
                        
                            <a href="/jekylls/2023-11-29-semantic_analysis.html" onclick="pageScrollToTop(this)">
                                Compiler | Semantic Analysis Notes
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-11-28-test_coverage_criteria.html">
                        
                            <a href="/jekyll/2023-11-28-test_coverage_criteria.html" onclick="pageScrollToTop(this)">
                                Note | Test Coverage Criteria
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-11-25-method_level_structural_unit_testing.html">
                        
                            <a href="/jekyll/2023-11-25-method_level_structural_unit_testing.html" onclick="pageScrollToTop(this)">
                                Testing | Method-Level Structural Unit Testing
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-11-24-deadlock.html">
                        
                            <a href="/jekyll/2023-11-24-deadlock.html" onclick="pageScrollToTop(this)">
                                OS | Deadlock
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-11-23-based_on_clp_testcases.html">
                        
                            <a href="/jekyll/2023-11-23-based_on_clp_testcases.html" onclick="pageScrollToTop(this)">
                                Testing | Based on CLP Testcases
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter active" data-level="1.2" data-path="/jekyll/2023-11-09-synchronization.html">
                        
                            <a href="/jekyll/2023-11-09-synchronization.html" onclick="pageScrollToTop(this)">
                                OS | Synchronization (Unfinished)
                            </a>
                            
                                
                                    <ul><li><a href="#critical-section" onclick="mobilePageScrollToAnchor(this)" >Critical Section</a></li><li><a href="#semaphore--mutex" onclick="mobilePageScrollToAnchor(this)" >Semaphore &amp; Mutex</a></li><li><a href="#use-semaphore-to-solve-common-problems" onclick="mobilePageScrollToAnchor(this)" >Use Semaphore to Solve Common Problems</a></li><li><a href="#atomic-operation" onclick="mobilePageScrollToAnchor(this)" >Atomic Operation</a></li><li><a href="#spinlock" onclick="mobilePageScrollToAnchor(this)" >Spinlock</a></li></ul>

                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-10-28-method_level_function_unit_testing.html">
                        
                            <a href="/jekyll/2023-10-28-method_level_function_unit_testing.html" onclick="pageScrollToTop(this)">
                                Testing | Method-Level Functional Unit Testing
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2023-10-26-syntax_analysis.html">
                        
                            <a href="/jekylls/2023-10-26-syntax_analysis.html" onclick="pageScrollToTop(this)">
                                Compiler | Syntax Analysis Notes
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-10-19-cpu_scheduler.html">
                        
                            <a href="/jekyll/2023-10-19-cpu_scheduler.html" onclick="pageScrollToTop(this)">
                                OS | CPU Scheduler
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-10-18-process_thread.html">
                        
                            <a href="/jekyll/2023-10-18-process_thread.html" onclick="pageScrollToTop(this)">
                                OS | Process and Thread
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-10-17-container_of.html">
                        
                            <a href="/jekyll/2023-10-17-container_of.html" onclick="pageScrollToTop(this)">
                                Note | Linux Kernel Macro container_of &amp; offsetof
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-10-10-test_case_generation.html">
                        
                            <a href="/jekyll/2023-10-10-test_case_generation.html" onclick="pageScrollToTop(this)">
                                Testing | Test Case Generation
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-10-09-operating_system_structure.html">
                        
                            <a href="/jekyll/2023-10-09-operating_system_structure.html" onclick="pageScrollToTop(this)">
                                OS | Operating System Structure
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-09-23-software_testing_introduction.html">
                        
                            <a href="/jekyll/2023-09-23-software_testing_introduction.html" onclick="pageScrollToTop(this)">
                                Testing | Software Testing Introduction
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekylls/2023-09-21-lexical_analysis.html">
                        
                            <a href="/jekylls/2023-09-21-lexical_analysis.html" onclick="pageScrollToTop(this)">
                                Compiler | Lexical Analysis Notes
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-09-20-compiler_introduction.html">
                        
                            <a href="/jekyll/2023-09-20-compiler_introduction.html" onclick="pageScrollToTop(this)">
                                Compiler | Compilers Introduction
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-09-12-operating_system_introduction.html">
                        
                            <a href="/jekyll/2023-09-12-operating_system_introduction.html" onclick="pageScrollToTop(this)">
                                OS | Operating System Introduction
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-09-07-test_case_generation_based_on_constraint_logic_graph.html">
                        
                            <a href="/jekyll/2023-09-07-test_case_generation_based_on_constraint_logic_graph.html" onclick="pageScrollToTop(this)">
                                Paper | Test Case Generation Based on Constraint Logic Graph
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-09-07-Introduction_OCL.html">
                        
                            <a href="/jekyll/2023-09-07-Introduction_OCL.html" onclick="pageScrollToTop(this)">
                                Note | Object Constraint Language Concepts (Unfinished)
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-08-06-gdb_introduction.html">
                        
                            <a href="/jekyll/2023-08-06-gdb_introduction.html" onclick="pageScrollToTop(this)">
                                Note | GNU Debugger Quick Notes
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-08-05-linux_kernel_complie.html">
                        
                            <a href="/jekyll/2023-08-05-linux_kernel_complie.html" onclick="pageScrollToTop(this)">
                                OS | Linux Kernel Compilation
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-07-28-UML_structure_diagrams.html">
                        
                            <a href="/jekyll/2023-07-28-UML_structure_diagrams.html" onclick="pageScrollToTop(this)">
                                Note | UML Structure Diagrams Introduction
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-07-28-UML_behavior_diagrams.html">
                        
                            <a href="/jekyll/2023-07-28-UML_behavior_diagrams.html" onclick="pageScrollToTop(this)">
                                Note | UML Behavior Diagrams Introduction (Unfinished)
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-07-26-unified_modeling_language.html">
                        
                            <a href="/jekyll/2023-07-26-unified_modeling_language.html" onclick="pageScrollToTop(this)">
                                Note | Unified Modeling Language Concepts
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-07-22-property_based_testing_entropy_guided_backbox_REST_API-_fuzzer.html">
                        
                            <a href="/jekyll/2023-07-22-property_based_testing_entropy_guided_backbox_REST_API-_fuzzer.html" onclick="pageScrollToTop(this)">
                                Paper | BenFuzz: A Property Based Testing and Entropy Guided Blackbox REST API Fuzzer
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-07-19-MVVM_modeling_methodology_user_interface.html">
                        
                            <a href="/jekyll/2023-07-19-MVVM_modeling_methodology_user_interface.html" onclick="pageScrollToTop(this)">
                                Paper | A MVVM Modeling Methodology for Information Systems User Interface Design
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-07-18-software_arch_pattern.html">
                        
                            <a href="/jekyll/2023-07-18-software_arch_pattern.html" onclick="pageScrollToTop(this)">
                                Note | Architectural Patterns Compare MVP, MVC, MVVM
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-07-18-automated_gen_test_case_using_UML.html">
                        
                            <a href="/jekyll/2023-07-18-automated_gen_test_case_using_UML.html" onclick="pageScrollToTop(this)">
                                Paper | Automated-generating test case using UML statechart diagrams (Unfinished)
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-06-23-Intergrated_environment_sdd.html">
                        
                            <a href="/jekyll/2023-06-23-Intergrated_environment_sdd.html" onclick="pageScrollToTop(this)">
                                Paper | An Integrated Environment for Specification Driven Development (Unfinished)
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-05-28-characteristics_of_bdd.html">
                        
                            <a href="/jekyll/2023-05-28-characteristics_of_bdd.html" onclick="pageScrollToTop(this)">
                                Paper | A Study of the Characteristics of Behaviour Driven Development
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-05-20-analysis_mutation_testing.html">
                        
                            <a href="/jekyll/2023-05-20-analysis_mutation_testing.html" onclick="pageScrollToTop(this)">
                                Paper | An Analysis and Survey of the Development of Mutation Testing
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-04-21-tdd_concepts.html">
                        
                            <a href="/jekyll/2023-04-21-tdd_concepts.html" onclick="pageScrollToTop(this)">
                                Paper | Test-driven development concepts, taxonomy, and future direction
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-04-18-applying_isoiec25010.html">
                        
                            <a href="/jekyll/2023-04-18-applying_isoiec25010.html" onclick="pageScrollToTop(this)">
                                Paper | Applying the ISO/IEC 25010 Quality Models to Software Product
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-04-13-software_standard.html">
                        
                            <a href="/jekyll/2023-04-13-software_standard.html" onclick="pageScrollToTop(this)">
                                Note | Standard - ISO/IEC
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-02-04-algorithm_kmp.html">
                        
                            <a href="/jekyll/2023-02-04-algorithm_kmp.html" onclick="pageScrollToTop(this)">
                                Leetcode | Algorithm - KMP
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2023-01-12-gomoku_ai.html">
                        
                            <a href="/jekyll/2023-01-12-gomoku_ai.html" onclick="pageScrollToTop(this)">
                                Note | Gomoku AI - Game Tree
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2022-11-24-git_commit.html">
                        
                            <a href="/jekyll/2022-11-24-git_commit.html" onclick="pageScrollToTop(this)">
                                Note | Commit Message Format
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2022-11-08-ai_csp.html">
                        
                            <a href="/jekyll/2022-11-08-ai_csp.html" onclick="pageScrollToTop(this)">
                                Note | Constraint Satisfaction Problem
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2022-11-07-network_urat.html">
                        
                            <a href="/jekyll/2022-11-07-network_urat.html" onclick="pageScrollToTop(this)">
                                Note | Basic UART Concept
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/2022-11-05-docker_jekyll.html">
                        
                            <a href="/jekyll/2022-11-05-docker_jekyll.html" onclick="pageScrollToTop(this)">
                                Note | Docker Build Github Pages
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/1970-01-01-virtual_machine_tool.html">
                        
                            <a href="/jekyll/1970-01-01-virtual_machine_tool.html" onclick="pageScrollToTop(this)">
                                Tool | Virtual Machine
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/1970-01-01-linux_config.html">
                        
                            <a href="/jekyll/1970-01-01-linux_config.html" onclick="pageScrollToTop(this)">
                                Tool | Linux Config
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/1970-01-01-leetcode_guide.html">
                        
                            <a href="/jekyll/1970-01-01-leetcode_guide.html" onclick="pageScrollToTop(this)">
                                Leetcode | Master Guide
                            </a>
                            
                                
                            
                        </li>
                    
                        
                        <li class="chapter" data-level="1.1" data-path="/jekyll/1970-01-01-editor_envirmnment.html">
                        
                            <a href="/jekyll/1970-01-01-editor_envirmnment.html" onclick="pageScrollToTop(this)">
                                Tool | Edirot Guide
                            </a>
                            
                                
                            
                        </li>
                    

                    
                        <li class="divider"></li>
                    
                
            
        </ul>
    </nav>
</div>
<div class="book-body">
                <div class="book-header" role="navigation">
                    <!-- Title -->
                    <h1>
                        <i class="fa fa-circle-o-notch fa-spin"></i>
                        
                            <a href="." >OS | Synchronization (Unfinished)</a>
                        
                    </h1>
                </div>

                <div class="body-inner"><div class="page-wrapper" tabindex="-1" role="main">
    

    <div class="page-inner">
        <div class="normal">
            
            
            <section class="normal">November 09, 2023 </section>
            
        </div>
        <div id="book-search-results">
            <div class="search-noresults">
                <section class="normal markdown-section">
                    
                        <h1 id="/jekyll/synchronization">OS | Synchronization (Unfinished)</h1>
                    

                    <blockquote class="block-tip">
  <p>Operating System: Design and Implementation course notes from CCU, lecturer Shiwu-Lo.</p>
</blockquote>

<p>這個章節主要講的是 Linux 中如果有多個 Task 同時存取記憶體，要怎麼去處理 Synchronization 的問題。</p>

<ul>
  <li>多個 Task 如果同時存取 Memory 會發生彼此複寫的問題
    <ul>
      <li>同時 Peripheral devices 在 MMIO 中也是一塊 Memory</li>
    </ul>
  </li>
  <li>要保護 Memory 最直覺的想法是不要讓會存取同一份 Memory 的 Task 同時執行
    <ul>
      <li>設計 Critical Section，避免 Task 同時執行</li>
      <li>Critical Section 還必須是有效率，公平的</li>
    </ul>
  </li>
  <li>具有啟發性的方法 Peterson’s solution
    <ul>
      <li>假設 read, write 是 atomic operation</li>
      <li>證明 Peterson’s solution 滿足 Critical Section 三個條件</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>Critical Section 三個條件: Mutual Exclusion, Progress, Bounded Waiting</p>
</blockquote>

<ul>
  <li>C11 實現 Peterson’s solution</li>
  <li>挑選合適的保護機制
    <ul>
      <li>Mutex( /semaphore) = spinlock + sleep + wakeup</li>
      <li>預期等待的時間很短，使用 spinlock，例如: (Peterson’s solution)</li>
      <li>需要等待一段時間，使用 mutex 或 semaphore</li>
      <li>上述的 sleep 與 wakeup 在 Linux 中由 system call <code class="language-plaintext highlighter-rouge">futex</code> 實現</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>spinlock 與 peterson’s solution 都類似於使用 while loop 來做 busy waiting</p>
</blockquote>

<ul>
  <li>常見的問題形式</li>
  <li>Producer-Consumer Problem(生產者與消費者問題)，例如: 驅動程式與周邊設備的溝通</li>
  <li>Dining Philosophers Problem(哲學家就餐問題)，例如: 多個 Task 之間的資源交換</li>
  <li>Reader-Writer Problem(讀者與寫者問題)，例如: 只有閱讀檔案而不修改檔案的 Task</li>
  <li>Multi-Process 同時存取時，要依照哪個 Process 的時間
    <ul>
      <li>或者如何保證分散式系統之間也能保證存取的正確性(版本概念)</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>最後討論一些深入的問題</p>
</blockquote>

<ul>
  <li>從硬體的角度來看 atomic operation 的實現
    <ul>
      <li>了解軟體使用的 atomic operation 的代價</li>
    </ul>
  </li>
  <li>以 Linux kernel 為例說明應用技巧
    <ul>
      <li>多種的 spinlock(C11 實現)，semaphore(以驅動程式為例)</li>
    </ul>
  </li>
  <li>更深入的討論 memory order
    <ul>
      <li>Atomic 在多處理器上要做到多少的保證</li>
    </ul>
  </li>
</ul>

<h5 id="51-multi-process-processing-one-data-at-the-same-time">5.1 Multi-Process processing one data at the same time</h5>

<p>這裡用一個簡單的例子來說明同時處理一筆資料會產生的問題，可以看到輸出結果並不是我們預期的，這是因為兩個 thread 同時存取 global 變數，造成彼此複寫的問題。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="n">global</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">thread</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="mi">1000000000</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">global</span><span class="o">+=</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_t</span> <span class="n">id1</span><span class="p">,</span> <span class="n">id2</span><span class="p">;</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id1</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="kr">thread</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">id2</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span> <span class="kr">thread</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">id1</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span><span class="n">pthread_join</span><span class="p">(</span><span class="n">id2</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"1000000000+1000000000 = %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">global</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 1000000000+1000000000 = 1037054916</span>
</code></pre></div></div>

<p>使用 <code class="language-plaintext highlighter-rouge">gcc -o exam1.exe exam1.c -g -</code> 之後使用 gdb 來查看程式碼，使用 <code class="language-plaintext highlighter-rouge">disassemble \m thread</code> 來反組譯觀察問題在哪，
<code class="language-plaintext highlighter-rouge">\m</code> 代表把 c 跟 assembly code 一起顯示。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb ./exam1.exe 
<span class="o">(</span>gdb<span class="o">)</span> disassemble /m thread 
Dump of assembler code <span class="k">for function </span>thread:
4       void thread<span class="o">(</span>void<span class="o">)</span> <span class="o">{</span>
   0x0000000000001159 &lt;+0&gt;:     push   %rbp
   0x000000000000115a &lt;+1&gt;:     mov    %rsp,%rbp

5           <span class="k">for</span> <span class="o">(</span>int <span class="nv">i</span><span class="o">=</span>0<span class="p">;</span> i&lt;1000000000<span class="p">;</span> i++<span class="o">)</span>
   0x000000000000115d &lt;+4&gt;:     movl   <span class="nv">$0x0</span>,-0x4<span class="o">(</span>%rbp<span class="o">)</span>
   0x0000000000001164 &lt;+11&gt;:    jmp    0x1179 &lt;thread+32&gt;
   0x0000000000001175 &lt;+28&gt;:    addl   <span class="nv">$0x1</span>,-0x4<span class="o">(</span>%rbp<span class="o">)</span>
   0x0000000000001179 &lt;+32&gt;:    cmpl   <span class="nv">$0x3b9ac9ff</span>,-0x4<span class="o">(</span>%rbp<span class="o">)</span>
   0x0000000000001180 &lt;+39&gt;:    jle    0x1166 &lt;thread+13&gt;

6               global+<span class="o">=</span>1<span class="p">;</span>
   0x0000000000001166 &lt;+13&gt;:    mov    0x2ec0<span class="o">(</span>%rip<span class="o">)</span>,%eax        <span class="c"># 0x402c &lt;global&gt;</span>
   0x000000000000116c &lt;+19&gt;:    add    <span class="nv">$0x1</span>,%eax
   0x000000000000116f &lt;+22&gt;:    mov    %eax,0x2eb7<span class="o">(</span>%rip<span class="o">)</span>        <span class="c"># 0x402c &lt;global&gt;</span>

7       <span class="o">}</span>
   0x0000000000001182 &lt;+41&gt;:    nop
   0x0000000000001183 &lt;+42&gt;:    nop
   0x0000000000001184 &lt;+43&gt;:    pop    %rbp
   0x0000000000001185 &lt;+44&gt;:    ret

End of assembler dump.
</code></pre></div></div>

<p>假設 global 的初始值為 0，在這個程式中有可能會依照這樣執行，CPU1 做完加法後寫入 %rip，CPU2 也做完加法後寫入 %rip，這樣就會造成彼此複寫的問題。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CPU1                            CPU2
1.  mov    0x2ec0<span class="o">(</span>%rip<span class="o">)</span>,%eax    1.
2.                              2.  mov    0x2ec0<span class="o">(</span>%rip<span class="o">)</span>,%eax
3.  add    <span class="nv">$0x1</span>,%eax            3.
4.  mov    %eax,0x2eb7<span class="o">(</span>%rip<span class="o">)</span>    4.
5.                              5.  add    <span class="nv">$0x1</span>,%eax
6.                              6.  mov    %eax,0x2eb7<span class="o">(</span>%rip<span class="o">)</span>
</code></pre></div></div>

<p>Atomicity 的意思就是當我們在對一個 Data struct 做操作時，要保證整個 struct 是一次性的更新，這裡的 global variable 是一個非常簡單的例子，但是在實際的程式中可能會有很複雜的 Data struct，
因此要保證整個 struct 是一次性的更新是非常困難的。</p>

<ul>
  <li><strong>Definition correct solution</strong>
    <ul>
      <li>一個正確的 Multi-thread program 應該要跟其對應的 Single-thread 的 program 有相同的行為</li>
    </ul>
  </li>
</ul>

<h3 id="critical-section">Critical Section</h3>

<p><a href="./2023-11-09-synchronization.html#52-race-condition-probkem">5.2 Race condition problem</a><br />
<a href="./2023-11-09-synchronization.html#53-critical-section-three-conditions">5.3 Critical section three conditions</a><br />
<a href="./2023-11-09-synchronization.html#54-petersons-solution">5.4 Peterson’s solution</a><br />
<a href="./2023-11-09-synchronization.html#55-proof-petersons-sol-to-satisfy-critical-section-three-conditions">5.5 Proof peterson’s solution</a><br />
<a href="./2023-11-09-synchronization.html#56-c11-implementation">5.6 C11 implementation</a></p>

<p>Critical section 其實就是一套協定，這套協定使多個 Task 之間可以互相合作</p>

<h5 id="52-race-condition-problem">5.2 Race condition problem</h5>

<p>Race condition(競爭條件)是指軟體系統的行為，當操作是基於無法控制順序的事件或時間，當這些事件沒依照 Programer 意圖的順序發生時，就會出現 bug。</p>

<ul>
  <li>Race condition 的其中一種解決方式就是
    <ul>
      <li>引入 Critical section，讓 Task 之間互相合作</li>
      <li>注意 Critical section 所保護的是程式碼</li>
    </ul>
  </li>
</ul>

<h5 id="53-critical-section-three-conditions">5.3 Critical section three conditions</h5>

<ol>
  <li>Mutual Exclusion(互斥, 基本條件)
    <ul>
      <li>如果有一個 Task 在執行 Critical section，那麼其他 Task 就不能執行 Critical section</li>
    </ul>
  </li>
  <li>Progress(進展, 有效率)
    <ul>
      <li>如果沒有 Task 在執行 Critical section，只有不在 Remainder section 的 Task 才能決定誰可以執行 Critical section，並且不能無限期的等待</li>
    </ul>
  </li>
  <li>Bounded Waiting(有界等待, 公平性)
    <ul>
      <li>如果有一個 Task 想要執行 Critical section，那麼就不能讓這個 Task 被無期限的等待</li>
      <li>例如: 有 A, B 兩個 Task，但故意永遠只讓 A 執行 Critical section，這樣 B 就會無限期的等待</li>
    </ul>
  </li>
</ol>

<p><img src="/image/2023/11-09-synchronization/1.png" alt="" height="100%" width="100%" /></p>

<blockquote>
  <p>libc 其實並沒有滿足 Bounded Waiting 的條件，在某些情況下會造成 starvation</p>
</blockquote>

<h5 id="54-petersons-solution">5.4 Peterson’s solution</h5>

<p><a href="https://en.wikipedia.org/wiki/Peterson%27s_algorithm">Peterson’s solution</a> 是一個完全解決 Race condition 的純軟體演算法</p>

<ul>
  <li>假設只有 P0, P1 兩個 Task</li>
  <li>對於硬體有一些基本假設
    <ul>
      <li><code class="language-plaintext highlighter-rouge">read</code>, <code class="language-plaintext highlighter-rouge">write</code> is atomic operation</li>
      <li>shard memory system
        <ul>
          <li>因為假設是 shard memory system，所以無法用在 distributed system</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Peterson’s solution 可以擴展到 N 個 Task</li>
</ul>

<ol>
  <li>假設 P0, P1 共享兩個變數
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">boolean</span> <span class="n">flag</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">};</span> <span class="cm">/* Represents who wants to enter the Critical section */</span>
<span class="kt">int</span> <span class="n">turn</span><span class="p">;</span> <span class="cm">/* 0 means P0, 1 means P1 has priority when entering the critical area */</span>
</code></pre></div>    </div>
  </li>
  <li>P0 source code
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>         <span class="cm">/* P0 wants to enter the critical section */</span>
    <span class="n">turn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>               <span class="cm">/* IF P1 wants to enter the critical section, P1 has priority */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">turn</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">;</span>                   <span class="cm">/* busy waiting */</span>
                            <span class="cm">/* critical section */</span>
        <span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>    <span class="cm">/* exit section */</span>
                            <span class="cm">/*remainder section */</span>
<span class="p">}</span>
</code></pre></div>    </div>
  </li>
  <li>注意 P0 會在 turn 優先讓 P1 進入 Critical section，同樣的 P1 也會在 turn 優先讓 P0 進入 Critical section
    <ul>
      <li>對方想進入 Critical section，那麼自己就讓對方進入 Critical section</li>
      <li>沒有人想進入 Critical section，那麼就自己進入 Critical section</li>
      <li>對方離開 Critical section 後，自己就可以進入 Critical section</li>
    </ul>
  </li>
</ol>

<h5 id="55-proof-petersons-sol-to-satisfy-critical-section-three-conditions">5.5 Proof peterson’s sol to satisfy critical section three conditions</h5>

<p>Proof:</p>
<ul>
  <li><strong>Mutual Exclusion</strong>
    <ul>
      <li>Shard memory 中，Task 都能修改 turn, 所以 turn 只會有兩個值，0 或 1</li>
      <li><code class="language-plaintext highlighter-rouge">write</code> 必須是 atomic operation，否則 P0, P1 有可能讀到不同的值</li>
    </ul>
  </li>
  <li><strong>Progress</strong>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.  flag[0] = true;                 1.  flag[1] = true;
2.  turn = 1;                       2.  turn = 0;
3.  while (flag[1] &amp;&amp; turn == 1)    3.  while (flag[0] &amp;&amp; turn == 0)
</code></pre></div>    </div>
    <ol>
      <li>假設 P0 想進入 CS，P1 沒有想進入 CS，<code class="language-plaintext highlighter-rouge">flag[1] = false</code>，這樣可以直接進入 CS</li>
      <li>假設 P0 想進入 CS，P1 只執行到 flag[1] = true，這樣 P0 會進入 busy waiting，但是 P1 會在 turn = 0 再次禮讓 P0 進入 CS</li>
      <li>假設 P0, P1 都同時執行到 while loop，但是 turn 會確保至少有一個 Task 會進入 CS</li>
    </ol>
  </li>
  <li><strong>Bound Waiting</strong>
    <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.  flag[0] = true;                 1.  flag[1] = true;
2.  turn = 1;                       2.  turn = 0;
3.  while (flag[1] &amp;&amp; turn == 1)    3.  while (flag[0] &amp;&amp; turn == 0)
4.  flag[0] = false;                4.  while (flag[0] &amp;&amp; turn == 0)
5.  flag[0] = true;                 5.  while (flag[0] &amp;&amp; turn == 0)
6.  turn = 1;                       6.  while (flag[0] &amp;&amp; turn == 0)
7   while (flag[1] &amp;&amp; turn == 1)    7.  while (flag[0] &amp;&amp; turn == 0)
</code></pre></div>    </div>
    <ul>
      <li>這裡的重點其實在於 turn，不是 flag，因為 flag 只是代表誰想進入 CS，但是 turn 代表誰有權利進入 CS</li>
      <li>假如 P0 把 flag 設為 false 的時候，剛好 P1 被 ctx 這樣也並不會錯過進入 CS 的機會</li>
      <li>所以在 P0 禮讓的情況下，P1 一定會在下次進入 CS</li>
    </ul>
  </li>
</ul>

<p>在這裡會覺得好像 flag, turn 的順序如果調換也會有一樣的效果，但是記住 flag 只是代表誰想進入 CS，但是 turn 代表誰有權利進入 CS，如果調換會有以下情況</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1.  while(1) {                          1.  while(1) {
2.      turn = 1;                       2.
3.                                      3.  turn = 0;
4.                                      4.  flag[1] = true;
5.                                      5.  while (flag[0] &amp;&amp; turn == 0)
6.      flag[0] = true;                 6.  /* Critical Section */
7.      while (flag[1] &amp;&amp; turn == 1)    7.
8.      /* Critical Section */          8.
9.                                      9.  flag[1] = false;
10.     flag[0] = false;                10. /* Remainder Section */
11.     /* Remainder Section */         11. }
12. }                                   12.
</code></pre></div></div>

<ol>
  <li>P1 進入 CS 但是是因為 flag[0] = false，而實際上 P0 也想進入 CS 只是還沒有執行到</li>
  <li>P0 進入 CS 但是是因為 turn = 0，對方禮讓但其實對方還在 CS 中只是還沒將 flag 設置為 false
    <ul>
      <li>這樣就會造成 P0, P1 同時進入 CS，違反 <code class="language-plaintext highlighter-rouge">Mutual Exclusion</code></li>
    </ul>
  </li>
</ol>

<p><strong>Proof flag must before turn:</strong></p>

<ol>
  <li>P0 和 P1 同時執行，都有可能去執行 turn，因此 turn 不是 0 就是 1</li>
  <li>這裡的前提是一定會有 <code class="language-plaintext highlighter-rouge">flag[0] == flag[1] == 1</code> 代表兩者都想進入 CS
    <ul>
      <li>這個步驟是必須的，必須先確認要進入 CS，之後才能去禮讓對方</li>
    </ul>
  </li>
</ol>

<blockquote>
  <p>理解這部分是為了如果之後要設計 spinlock，即使有很多已經寫好的演算法，但是依然有可能在特別的情況下需要自己設計，此時理解這部分的證明就非常重要</p>
</blockquote>

<h5 id="56-c11-implementation">5.6 C11 implementation</h5>

<p>在 C11 實作的時候要注意的是使用 <stdatomic.h> 這個標頭檔，並且要注意 Compiler 在做 Optimization，有可能把重要的部份給省略掉，
因為 Optimization 保證的是 Single-thread 的行為，所以在 Multi-thread 的行為上就不一定會正確。</stdatomic.h></p>

<p><a href="https://gist.github.com/Hotshot824/c8d89af9fb5481a4a257d5692301490f">peterson’s-sol.c</a>， P0 的程式碼如下，注意到要使用 <code class="language-plaintext highlighter-rouge">atomic_store</code> 進行操作，並且在 <code class="language-plaintext highlighter-rouge">atomic_thread_fence()</code> 來保證編譯器最佳化不會修改程式碼的順序。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">atomic_int</span> <span class="n">turn</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span>
<span class="n">atomic_int</span> <span class="n">flag</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">}</span>
<span class="kt">void</span> <span class="nf">p0</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"start p0</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">atomic_store</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">atomic_thread_fence</span><span class="p">(</span><span class="n">memory_order_seq_cst</span><span class="p">);</span>
        <span class="n">atomic_store</span><span class="p">(</span><span class="o">&amp;</span><span class="n">turn</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">atomic_load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_load</span><span class="p">(</span><span class="o">&amp;</span><span class="n">turn</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">)</span>
            <span class="p">;</span>
        <span class="cm">/* Critical Section */</span>
        <span class="n">in_cs</span><span class="o">++</span><span class="p">;</span>
        <span class="n">nanosleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">in_cs</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"p0及p1都在critical section</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
            <span class="n">p0_in_cs</span><span class="o">++</span><span class="p">;</span>
        <span class="n">nanosleep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">in_cs</span><span class="o">--</span><span class="p">;</span>
        <span class="cm">/* Remainder Section */</span>
        <span class="n">atomic_store</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flag</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>這個程式的執行將會如下，可以看到無論多少次執行這兩個 Task 進入 CS 的次數都在 1 的範圍內。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./peterson
start p0
start p1
p0: 3333, p1: 3332
p0: 6684, p1: 6684
p0: 10046, p1: 10046
p0: 13401, p1: 13400
p0: 16768, p1: 16768
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">atomic_sotre()</code> 隱含需要使用 <code class="language-plaintext highlighter-rouge">atomic_thread_fence()</code></li>
  <li>如果想要更高效率的 code 應該使用:
    <ul>
      <li><code class="language-plaintext highlighter-rouge">atomic_store_explicit(address, memory_order)</code></li>
      <li><code class="language-plaintext highlighter-rouge">atomic_load_explicit(address, memory_order)</code></li>
      <li>memory_order 指定使用哪一種記憶體模型</li>
    </ul>
  </li>
  <li>另外要注意在 <code class="language-plaintext highlighter-rouge">signal</code> handler 中不應該使用 <code class="language-plaintext highlighter-rouge">printf()</code> 這部粉可以參考系統程式設計</li>
</ul>

<p><strong>Peterson’s solution conclusion</strong></p>

<ul>
  <li>Peterson’s solution 提供一個滿足 Critical section 三個條件的純軟體演算法</li>
  <li>如果 Critical section 很長，CPU 會浪費大量時間在 Busy waiting
    <ul>
      <li>例如: P0 進入 CS 後要執行約 1 分鐘，P1 會在這段時間一直在 Busy waiting，如果是這樣 P1 應該要釋放 CPU 給其他 Task 先使用，
等到時間到了再去檢查是否可以進入 CS，例如: <code class="language-plaintext highlighter-rouge">mutex</code> 使用 adaptive 的方式</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>mutex 後面參數的 <code class="language-plaintext highlighter-rouge">PTHREAD_MUTEX_ADAPTIVE_NP</code> 代表使用 adaptive 的方式，這樣就可以避免 busy waiting</p>
</blockquote>

<hr />

<h3 id="semaphore--mutex">Semaphore &amp; Mutex</h3>

<p><a href="./2023-11-09-synchronization.html#57-definition-of-semaphore">5.7 Definition of Semaphore</a><br />
<a href="./2023-11-09-synchronization.html#58-mutex">5.8 Mutex</a><br />
<a href="./2023-11-09-synchronization.html#59-mutex-in-libc">5.9 Mutex in libc</a><br />
<a href="./2023-11-09-synchronization.html#510-futex-in-linux">5.10 Futex in Linux</a></p>

<p>這裡來介紹與 Peterson’s solution 不太一樣的機制 Mutex 與 Semaphore，最主要的差異是有可能產生 context switch，並且跟 spinlock 不同的應用場景有哪些。
實際上 Mutex 與 Semaphore 都有 spinlock, sleep, wakeup 這三個機制所實作。</p>

<h5 id="the-difference-between-mutex-and-spinlock">The difference between Mutex and Spinlock</h5>

<ul>
  <li>Mutex lock 不成功時，幾乎都會去做 context switch
    <ul>
      <li>context switch 需要去耗費一些 CPU time，所以除非要等很久否則使用 semaphore 會比較好</li>
    </ul>
  </li>
  <li>Spinlock lock 不成功時，會一直做 busy waiting(Loop)
    <ul>
      <li>loop 會讓 CPU 不斷嘗試進入 CS，但如果等待太久會造成 CPU 資源的浪費</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>等待時間長應該使用 Mutex，等待時間短應該使用 Spinlock</p>
</blockquote>

<ul>
  <li>Spinlock 通常效能比 Mutex 好，所以 Database 等大型軟體會使用 Spinlock
    <ul>
      <li>但如果 task 持有 lock 但被 scheduleout，會造成其他 task 一直在 busy waiting</li>
    </ul>
  </li>
  <li>Semaphore, Mutex 中等待的 task 都被 scheduleout，所以不會造成 busy waiting</li>
</ul>

<h5 id="57-definition-of-semaphore">5.7 Definition of Semaphore</h5>

<p><strong>Semaphore 的定義:</strong></p>
<ul>
  <li>假如現在有 P1 - P4 要進入 CS 都執行到 while(S &lt;= 0)
    <ul>
      <li>此時持有 lock 的 task 發出 signal，S++</li>
      <li>P1 - P4 一定會有一個人離開 while loop，執行 S–;
        <ul>
          <li>在這裡必須假設這個步驟是一次執行完畢，所以不會有其他 task 同時離開 while loop</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>要注意這裡只是一個定義，而不是實現的方式</li>
</ul>

<p><img src="/image/2023/11-09-synchronization/2.png" alt="" height="100%" width="100%" /></p>

<p><strong>Semphore 的實作樣貌:</strong></p>
<ul>
  <li>wait: 想要進入 CS 的 task 呼叫 wait()
    <ol>
      <li>value–, 如果 value &lt; 0 就進入 list 等待</li>
      <li>sleep(), 呼叫 scheduler context switch</li>
    </ol>
  </li>
  <li>signal: 離開 CS 的 task 呼叫 signal()
    <ol>
      <li>value++, 如果 value &lt;= 0 代表有 task 在等待</li>
      <li>wakeup(), 從 list 中取出一個 task 並且喚醒從 sleep() 往下執行</li>
    </ol>
  </li>
</ul>

<p><img src="/image/2023/11-09-synchronization/3.png" alt="" height="100%" width="100%" /></p>

<p><strong>Semphore 的使用方式:</strong></p>
<ul>
  <li>Semphore 的 value 可以是:
    <ul>
      <li><strong>0&lt;</strong>: 代表有多個 task 在等待</li>
      <li><strong>=0</strong>: 沒有 task 在等待，通常是初始化的狀態</li>
      <li><strong>&gt;0</strong>: 代表一次最多有 X 個 task 可以進入 CS
        <ul>
          <li>例如: 一次最多 3 個 task 可以進入 CS，value 的初始值就是 3，進入 3 台後 value = 0，此時下一個 task 執行 value– 就會進入 list 等待</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>通常會有一個 Struct 來管理 Semphore，value 是無法直接修改的，必須使用他設計的函數</li>
</ul>

<h5 id="58-mutex">5.8 Mutex</h5>

<p>相較於 Semphore，Mutex 可以有更多特色</p>
<ul>
  <li>可以判斷是誰 Lock 住 Mutex (owner)</li>
  <li>可以支援 Priority inheritance</li>
  <li>可以支援或不支援 Nested lock</li>
  <li>可以支援 Adaptive lock
    <ul>
      <li>假如我不知道應該使用 spinlock 還是 mutex，可以使用 adaptive lock，這樣就可以自動選擇</li>
    </ul>
  </li>
</ul>

<p><strong>Adaptive Mutex</strong></p>

<p>如果 <strong>p</strong> 和 <strong>q</strong> 競爭 Mutex(lock)，這裡討論 p 的情況</p>
<ul>
  <li>Mutex 沒上鎖，p 獲得 lock</li>
  <li>Mutex 已上鎖，q 持有 lock
    <ol>
      <li>q 在另一顆 CPU，並且 q 在 OS 的 waiting queue 中，例如: q 在等待 I/O
        <ul>
          <li>p 會進入 sleep 等待 mutex(context switch)</li>
          <li>q 既然已經進入了 waiting queue 那代表可能在這一個 epoch 內都不會再執行，那麼 p 也就不需要再去痴痴等待了</li>
        </ul>
      </li>
      <li>q 在另一顆 CPU，但是 q 不在 OS 的 waiting queue 中，代表 q 在運算
        <ul>
          <li>p 會進入 busy waiting，直到 q 釋放 lock</li>
          <li>q 因為在執行，所以代表 q 會在短時間內釋放 lock，因此 p 去 spinlock 等待或許比 ctx 更有效率</li>
        </ul>
      </li>
      <li>q 和 p 在同一顆 CPU，則 p 進入 sleep 等待 mutex(context switch)
        <ul>
          <li>既然在同一顆 CPU，那麼 p 跑去做 busy waiting 也沒有意義，反而去搶奪 CPU 資源造成 q 也變慢，
q 變慢代表 q 釋放 lock 的時間也會變慢，因此 p 進入 sleep 等待 mutex 會比較好</li>
          <li>這裡可以藉由硬體的支援，來使用例如 pause(), mwait() 這樣的指令來讓 p 的 vcore 變慢，讓 q 有機會釋放 lock</li>
        </ul>
      </li>
    </ol>
  </li>
</ul>

<blockquote class="block-warning">
  <p>以上的這些情境都代表 p 必須要知道 mutex 持有者的狀態，這樣才能決定自己要進入 sleep 還是 busy waiting</p>
</blockquote>

<blockquote>
  <p>這邊介紹的 Adaptive Mutex 出自於 Sun Solaris，Adaptive 還有很多實作方式</p>
</blockquote>

<h5 id="59-mutex-in-libc">5.9 Mutex in libc</h5>

<p><a href="https://github.com/lattera/glibc/blob/master/nptl/pthread_mutex_lock.c">glibc/nptl/pthread_mutex_lock.c</a> glibc 中的 Adaptive Mutex 實作則是去依照過去等待這個 lock 所釋放的時間來設定 <strong>spinlock</strong> 的 loop 次數，
如果超過次數還無法成功，那就釋放 CPU 資源，並且進入 sleep。</p>
<ul>
  <li>LLL_MUTEX_LOCK(mutex)</li>
</ul>

<blockquote class="block-warning">
  <p>如果需要使用 Lock 的時候，如果對系統不熟悉，盡量避免隨便去使用 spinlock，可以使用 Adaptive Mutex</p>
</blockquote>

<p><a href="https://gist.github.com/Hotshot824/696bc2c9bede5a64a13f3e330a51c34b">signal-wait-adptive-mutex.c</a> 我們來執行這個範例程式:</p>
<ul>
  <li>在這個程式中使用了 semaphore 來確保 p 會比 q 先執行</li>
  <li>去觀察 p 是否執行 usleep()
    <ul>
      <li>有，context switch 的次數變多，因為 q 等不到 p 釋放 lock，所以 q 會去做 context switch</li>
      <li>沒有，context switch 的次數變少，因為程式很短，所以 q 會去做 busy waiting 等 p 釋放 lock</li>
    </ul>
  </li>
</ul>

<p><img src="/image/2023/11-09-synchronization/4.png" alt="" height="100%" width="100%" /></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Performance counter stats <span class="k">for</span> <span class="s1">'./exam3.exe'</span>:

              6.45 msec task-clock                       <span class="c">#    0.598 CPUs utilized          </span>
               200      context-switches                 <span class="c">#   31.027 K/sec                  </span>
                 0      cpu-migrations                   <span class="c">#    0.000 /sec                   </span>
                57      page-faults                      <span class="c">#    8.843 K/sec                  </span>
   &lt;not supported&gt;      cycles                                                      
                 0      stalled-cycles-frontend                                            
                 0      stalled-cycles-backend           <span class="c">#    0.00% backend cycles idle    </span>
   &lt;not supported&gt;      instructions                                                
   &lt;not supported&gt;      branches                                                    
   &lt;not supported&gt;      branch-misses                                               

       0.010775604 seconds <span class="nb">time </span>elapsed

       0.000000000 seconds user
       0.010204000 seconds sys
</code></pre></div></div>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code> Performance counter stats <span class="k">for</span> <span class="s1">'./exam3.exe -s'</span>:

             11.75 msec task-clock                       <span class="c">#    0.529 CPUs utilized          </span>
               400      context-switches                 <span class="c">#   34.055 K/sec                  </span>
                 0      cpu-migrations                   <span class="c">#    0.000 /sec                   </span>
                60      page-faults                      <span class="c">#    5.108 K/sec                  </span>
   &lt;not supported&gt;      cycles                                                      
                 0      stalled-cycles-frontend                                            
                 0      stalled-cycles-backend           <span class="c">#    0.00% backend cycles idle    </span>
   &lt;not supported&gt;      instructions                                                
   &lt;not supported&gt;      branches                                                    
   &lt;not supported&gt;      branch-misses                                               

       0.022206888 seconds <span class="nb">time </span>elapsed

       0.000000000 seconds user
       0.018481000 seconds sys
</code></pre></div></div>

<blockquote>
  <p>上面是去執行 perf 的結果，與預期的結果相符</p>
</blockquote>

<p><strong>Pthread mutex function</strong></p>

<ul>
  <li><code class="language-plaintext highlighter-rouge">pthread_mutex_init()</code>: Initialize mutex</li>
  <li><code class="language-plaintext highlighter-rouge">pthread_mutex_destroy()</code>: Destroy mutex</li>
  <li><code class="language-plaintext highlighter-rouge">pthread_mutex_lock()</code>: Lock mutex(blocking)</li>
  <li><code class="language-plaintext highlighter-rouge">pthread_mutex_trylock()</code>: Lock mutex(non-blocking), if mutex is unlocked, lock it and return 0, else return EBUSY.</li>
  <li><code class="language-plaintext highlighter-rouge">pthread_mutex_unlock()</code>: Unlock mutex</li>
  <li><code class="language-plaintext highlighter-rouge">pthread_mutexattr_()</code>: Mutex attribute</li>
</ul>

<h5 id="510-futex-in-linux">5.10 Futex in Linux</h5>

<p>Spinlock 可以直接在 userspace 實作，與 Kernel 無關，但想去實作 Semaphore, Mutex 就需要 Kernel 的支援，因為這兩個機制都需要去做 context switch，
<a href="https://man7.org/linux/man-pages/man2/futex.2.html">futex</a> 就是 Linux kernel 提供的一個機制，可以在 userspace 實現 Semaphore, Mutex。</p>

<ul>
  <li>futex 會透過 futex_op 來決定 mutex 的行為</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">syscall</span><span class="p">(</span><span class="n">SYS_futex</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">uaddr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">futex_op</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">val</span><span class="p">,</span>
            <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">timeout</span><span class="p">,</span>   <span class="cm">/* or: uint32_t val2 */</span>
            <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">uaddr2</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">val3</span><span class="p">);</span>

<span class="c1">// Note: glibc provides no wrapper for futex(), necessitating the use of syscall(2).</span>
</code></pre></div></div>

<blockquote class="block-danger">
  <p>注意 glibc 中並沒有去實作 futex()，因為這是一個僅限於 Linux 的系統呼叫，所以要使用 syscall() 來呼叫<br />
syscall(SYS_futex, uaddr, FUTEX_WAIT, val, timeout, uaddr2, val3);</p>
</blockquote>

<p><strong>futex - fast user-space locking</strong></p>
<ul>
  <li>以下的 Function 都只是把 <code class="language-plaintext highlighter-rouge">int futex_op</code> 來當作 Pseudo code 來看</li>
  <li>Main fuctions
    <ul>
      <li>futex_wait(&amp;expected, desired, timeout)
        <ul>
          <li>等待 expected == desired，timeout 代表等待的時間，如果 timeout == NULL 代表無限期等待</li>
        </ul>
      </li>
      <li>futex_wake(&amp;val, newVal, maxWakeup)
        <ul>
          <li>把 val 設為 newVal，並且喚醒 maxWakeup 個等待該 val 變為 newVal 的 task</li>
        </ul>
      </li>
    </ul>
  </li>
  <li><strong>Priority Inheritance(優先權繼承)</strong>: 這是為了避免 Priority Inversion(優先權反轉)所設計的
    <ul>
      <li>futex_wait_pi(&amp;expected, desired, timeout)</li>
      <li>futex_wakeup_pi(&amp;val, newVal, maxWakeup)</li>
      <li>如果正在等待的 task 中有比自己優先權高的 task，持有 lock 的 task 在持有 lock 的期間會把自己的優先權提升到跟等待的 task 同等</li>
      <li>Unlock 後優先權最高的 task 會優先取得 lock</li>
    </ul>
  </li>
</ul>

<blockquote class="block-warning">
  <p>Priority Inversion 是指低優先權的 task 持有 lock，但是高優先權的 task 此時也想持有 lock，導致高優先權的 task 等待低優先權的 task 釋放 lock</p>
</blockquote>

<hr />

<h3 id="use-semaphore-to-solve-common-problems">Use Semaphore to Solve Common Problems</h3>

<p><a href="./2023-11-09-synchronization.html#511-producer-consumer-problem">5.11 Producer-Consumer Problem</a><br />
<a href="./2023-11-09-synchronization.html#512-readers-writers-problem">5.12 Readers-Writers Problem</a><br />
<a href="./2023-11-09-synchronization.html#513-dining-philosophers-problem">5.13 Dining Philosophers Problem</a><br />
<a href="./2023-11-09-synchronization.html#514-514-what-is-the-correct">5.14 What is the correct</a></p>

<h5 id="511-producer-consumer-problem">5.11 Producer-Consumer Problem</h5>

<ul>
  <li>比較簡單的情況是「一個 Producer」、「一個 Consumer」
    <ul>
      <li>這種情況下使用 atomic_write, atomic_read 來創造一個 out, in 的 <a href="https://en.wikipedia.org/wiki/Circular_buffer">Circular queue</a> 來解決</li>
    </ul>
  </li>
  <li>「多個 Producer」、「多個 Consumer」，例如: 多個 Produer 同時要修改 in
    <ul>
      <li>如果有 read + modify(compare) + write 可以用一個硬體指令來解決，是否是比較有效率的方式?</li>
    </ul>
  </li>
</ul>

<p><img src="https://media.geeksforgeeks.org/wp-content/uploads/Circular-queue_1.png" alt="" height="100%" width="100%" /></p>

<blockquote>
  <p>上圖是 Circular queue 的概念，這裡的 in, out 代表的是 index，而不是實際的資料</p>
</blockquote>

<p><img src="/image/2023/11-09-synchronization/5.png" alt="" height="100%" width="100%" /></p>

<blockquote>
  <p>以上是一個範例，假設 Producer 是 NIC，Consumer 是 OS</p>
</blockquote>

<ul>
  <li>Queue 儲存的可能是一個 pointer，指向儲存資料的記憶體
    <ul>
      <li>NIC 透過 DMA 把資料寫入記憶體，並且修改 in</li>
      <li>OS 取完資料後，修改 out</li>
    </ul>
  </li>
  <li>假如此時是一對一的情況，解決方法如下，注意這裡其實應該要使用 atomic 來實作:
    <ul>
      <li>Producer 會執行 insert() 寫入資料
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">insert</span><span class="p">()</span> <span class="p">{</span>
<span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">item</span> <span class="o">=</span> <span class="n">input</span><span class="p">();</span> <span class="cm">/* Produce an item */</span>
    <span class="k">while</span> <span class="p">(((</span><span class="n">in</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">)</span> <span class="o">==</span> <span class="n">out</span><span class="p">)</span> <span class="cm">/* Only read in and out */</span>
        <span class="p">;</span> <span class="cm">/* Busy waiting, because no free buffer */</span>
    <span class="n">buffer</span><span class="p">[</span><span class="n">in</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span> <span class="cm">/* Insert item */</span>
    <span class="n">in</span> <span class="o">=</span> <span class="p">(</span><span class="n">in</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span> <span class="cm">/* Update in */</span>
<span class="p">}</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>Consumer 會執行 remove() 讀取資料
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">remove</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">in</span> <span class="o">==</span> <span class="n">out</span><span class="p">)</span> <span class="cm">/* Only read in and out */</span>
          <span class="p">;</span> <span class="cm">/* Busy waiting, because no free buffer */</span>
      <span class="n">item</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">out</span><span class="p">];</span> <span class="cm">/* Remove item */</span>
      <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">BUFFER_SIZE</span><span class="p">;</span> <span class="cm">/* Update out */</span>
      <span class="n">output</span><span class="p">(</span><span class="n">item</span><span class="p">);</span> <span class="cm">/* Consume the item */</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
      <li>在這個例子裡面 in, out 都只有一個 task 會去修改，所以只要使用 atomic_write, atomic_read 就可以解決</li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>要注意上面的例子都使用了 Busy waiting，如果程式並沒有高速的讀寫，那麼這樣的做法會造成 CPU 資源的浪費</p>
</blockquote>

<h5 id="512-readers-writers-problem">5.12 Readers-Writers Problem</h5>

<ul>
  <li>Reader-Writer Problem 的定義如下:
    <ul>
      <li>Reader 只可以讀，Writer 可以讀也可以寫</li>
      <li>Reader 可以同時多個 Reader 一起讀同一個資料結構</li>
      <li>Writer 同一時間內只能有一個去存取資料結構</li>
    </ul>
  </li>
  <li>實作上我們假設有一系列的 Writer, Reader 進入排序準備進入 CS: <code class="language-plaintext highlighter-rouge">rrrwrr</code>
    <ol>
      <li>把 <code class="language-plaintext highlighter-rouge">rrrwrr</code> 轉換成 <code class="language-plaintext highlighter-rouge">rrrrrw</code> 優先處理 Reader
        <ul>
          <li>但這樣的問題是，假如同一時間內不斷有 r 進入，那麼 w 就會一直等待，必須設計一個機制處理 w</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">rrrwrr，r</code> 跟 w 之間必須 FIFO，但連續的 r 可以同時進入 CS
        <ul>
          <li>所以執行順序會變成 <code class="language-plaintext highlighter-rouge">rrr</code> -&gt; <code class="language-plaintext highlighter-rouge">w</code> -&gt; <code class="language-plaintext highlighter-rouge">rr</code></li>
        </ul>
      </li>
    </ol>
  </li>
  <li>這裡的目標是盡量提高平行度，讓多個 Reader 同時進入 CS</li>
</ul>

<p><img src="/image/2023/11-09-synchronization/6.png" alt="" height="100%" width="100%" /></p>

<p>假如有以上範例程式:</p>
<ul>
  <li>writer 只需要去 wait(rw_mutex) 也就是 lock，跟 signal(rw_mutex) 也就是 unlock 就可以</li>
  <li>reader:
    <ol>
      <li>最開頭的 wait(mutex) 到 signal(mutex) 是為了 lock CS 讓此時只有 reader 可以進入
        <ul>
          <li>readcount == 1 代表這是第一個 reader，所以要去 lock CS 不讓 writer 進入</li>
        </ul>
      </li>
      <li>離開要檢查 readcount == 0 代表最後一個離開的 reader，unlock 讓 writer 此時可以進入</li>
    </ol>
  </li>
  <li>假設現在有一個 writer 正在 CS 中，此時有 r0, r1, r2 要進入 CS
    <ol>
      <li>r0 會先進入 wait(rw_mutex)，此時 writer 正在 CS 中，所以 r0 會進入 sleep</li>
      <li>r1, r2 會進入 wait(mutex)，lock 被 r0 拿走，所以 r1, r2 會進入 sleep</li>
      <li>writer 離開 CS 並且 signal(rw_mutex)，此時 r0 會 singal(mutex)，讓 r1, r2 可以依序進入 Reading</li>
    </ol>
  </li>
</ul>

<blockquote>
  <p>在實際使用時，可以使用 pthread 內建的 rwlock</p>
</blockquote>

<h5 id="513-dining-philosophers-problem">5.13 Dining Philosophers Problem</h5>

<p>如下圖所示，一群哲學家坐在圓桌上，每個哲學家面前都有一個盤子，而盤子之間交錯著刀叉</p>
<ul>
  <li>哲學家吃飯時必須拿起左右兩邊的刀叉才能吃飯</li>
  <li>有什麼方法讓所有的哲學家都能吃到飯?</li>
</ul>

<p><img src="/image/2023/11-09-synchronization/7.png" alt="" height="100%" width="100%" /></p>

<p>可能的解決方法:</p>
<ol>
  <li>所有人都先拿左邊的餐具，再拿右邊的餐具
    <ul>
      <li>可能所有人都拿到左邊的餐具，都等不到右邊的餐具，造成死結</li>
    </ul>
  </li>
  <li>對所有人編號，奇數先拿左邊的餐具，偶數先拿右邊的餐具
    <ul>
      <li>有可能有人運氣很差，一直拿不到餐具，不符合 Bound waiting</li>
    </ul>
  </li>
  <li>輪流獲得高優先權，拿到餐具的人可以吃飯然後放下餐具，直到所有人都吃完
    <ul>
      <li>輪流獲得高優先權，可能會造成效能瓶頸</li>
    </ul>
  </li>
</ol>

<p><strong>The Dining Philosophers Problem in Linux Kernel</strong></p>

<p><img src="/image/2023/11-09-synchronization/8.png" alt="" height="100%" width="100%" /></p>

<ul>
  <li>每顆 CPU 上都有一個 migration thread，當 CPU 有空閒時，migration thread 會去檢查有沒有 task 想要執行</li>
  <li>pull: migration/0 發現我的工作量太少，所以去搬移 migration/3 的工作</li>
  <li>push: migration/3 發現我的工作量太多，所以把工作搬移給 migration/0</li>
  <li>此時就要避免 migration/0, migration/3 重複了搬移工作，例如:
    <ol>
      <li>依照 CPU 編號，優先鎖編號小的 CPU，這樣就只有一個 migration thread 會先執行</li>
      <li>搬移結束後此時工作量會平均，所以不會再有 migration thread 去搬移工作</li>
    </ol>
  </li>
</ul>

<blockquote>
  <p>在這個例子 Linux 並沒有去考慮 bound waiting，因為 0 成功了的話 1 也就不用執行了</p>
</blockquote>

<h5 id="514-what-is-the-correct">5.14 What is the correct</h5>

<p>當多個 Process 同時在執行，在修改的時候要怎麼去確保資料的正確性，什麼是正確的?</p>

<p>假如有 Task1, Task2 同時要修改一個資料 A</p>
<ol>
  <li>Task2 先讀取 A，然後以 A 為基礎做一些運算</li>
  <li>Task1 在 Task 讀取後，才讀取 A 並修改 A，然後 Task2 才結束運算
    <ul>
      <li>這樣的情況下 Task2 最後運算的結果是錯誤的，因為 Task2 以 A 為基礎做運算，但是 A 已經被 Task1 修改了</li>
    </ul>
  </li>
</ol>

<p>同樣兩個 Task，但是這次 Task2 在 Task1 讀取前就做完運算</p>
<ul>
  <li>但是實際上這兩次 Task2 最後的結果都是一樣的</li>
  <li>因此如果以 Task2 的結果來判斷正確性，那麼可以說這兩次情景是等價的</li>
</ul>

<p><img src="/image/2023/11-09-synchronization/9.png" alt="" height="100%" width="100%" /></p>

<blockquote>
  <p>是否可以把平行化以後的正確性定義為「其結果等價於某個依序執行的狀況」</p>
</blockquote>

<hr />

<h3 id="atomic-operation">Atomic Operation</h3>

<blockquote class="block-warning">
  <p>前面會先介紹 Computer Orangization 的一些基礎，後面介紹使用 Atomic Operation 所產生的成本</p>
</blockquote>

<p><a href="./2023-11-09-synchronization.html#515-mesh-architecture">5.15 Mesh-Architecture</a><br />
<a href="./2023-11-09-synchronization.html#516-dma-with-cache-coherence">5.16 DMA with Cache Coherence</a><br />
<a href="./2023-11-09-synchronization.html#517-cache-coherence-vs-atomic-operation">5.17 Cache coherence vs Atomic operation</a><br />
<a href="./2023-11-09-synchronization.html#518-atomic-operation">5.18 Atomic operation</a><br />
<a href="./2023-11-09-synchronization.html#519-atomic-operation-in-c11">5.19 Atomic operation in c11</a></p>

<p>使用 Atomic operation 所產生的成本跟一般的指令不太一樣，並且會依照受影響的 CPU 的個數而有所不同。並且在 SMP 上如果所有 CPU 每次存取資料都要到 DRAM，
那 DRAM 就會是一個 Bottleneck，所以會有 Cache 的機制，但是 Cache 就要去處理 Cache coherence 的問題。</p>

<blockquote>
  <p>在同步機制上，不同的指令會影響到的 CPU 數量不同，所以成本也不同</p>
</blockquote>

<p><img src="/image/2023/11-09-synchronization/10.png" alt="" height="100%" width="100%" /></p>

<p>上圖中 L2 cache 之間會有一些同步機制，而 L3 chache 也會有一些同步機制，例如: <a href="https://en.wikipedia.org/wiki/Bus_snooping">SNOOP</a> + dictionary</p>

<p><strong>Bus</strong>
Bus 也有各種各樣的類型</p>
<ul>
  <li>支援 Broadcast 的 Bus (Core 數量少)</li>
  <li><a href="https://en.wikipedia.org/wiki/Ring_network">Ring</a> Bus (Core 數量多)</li>
  <li><a href="https://en.wikipedia.org/wiki/Mesh_networking">Mesh</a> Bus (Core 數量極多)</li>
  <li>不規則的連接圖 (AMD 階層式架構)</li>
</ul>

<h5 id="515-mesh-architecture">5.15 Mesh-Architecture</h5>

<p>這裡以 <a href="https://www.intel.com/content/www/us/en/developer/articles/technical/xeon-processor-scalable-family-technical-overview.html">Intel® Xeon® Processor Scalable Family Technical Overview</a> 為例，來了解 Coherence 的代價</p>

<p><img src="/image/2023/11-09-synchronization/11.png" alt="" height="100%" width="100%" /></p>

<ul>
  <li>Core 傳遞資料的方式是透過 Mesh，先走 X 再走 Y
    <ul>
      <li>CHA(Cache Home Agent): 類似 directory，記錄資料在那些 Core</li>
      <li>SF(Snoop Filter): 監聽 Bus 上的廣播，是否與自己有關</li>
      <li>LLC(Last Level Cache): 最後一層的 Cache</li>
    </ul>
  </li>
  <li>最上層就是對外的通訊介面，例如: PCIe, UPI</li>
  <li>左右各有一個通道，用來連接 DDR4，所以左右的 Core 會優先使用自己側的 DDR4</li>
</ul>

<p><strong>Ultra Path Interconnect(UPI)</strong></p>

<p><img src="/image/2023/11-09-synchronization/12.png" alt="" height="100%" width="100%" /></p>

<ul>
  <li>UPI 是一種擴展系統的一致性協定，讓多個處理器可以共享資料，並且在同一個 Memory space</li>
  <li>支援 UPI 的 Intel Xeon 處理器會提供 2~3 個 UPI 通道，來連接到其他 Xeon 處理器</li>
  <li>UPI 之間使用 Directory-based home snoop coherency protocol 來維持一致性</li>
</ul>

<p><strong>Cache Coherence</strong></p>

<p>CPU 必須用一些方法保證所有的 Core 看到的資料都是一致的，否則 Shared Memory 就沒有意義</p>
<ul>
  <li>Cache coherence problem: 不同 CPU 有不同的 Cache，所以可能會有新舊資料的問題</li>
  <li>Cache coherence protocol: 一種機制，用來確保所有 CPU 看到的資料都是一致的
    <ul>
      <li>Snooping: 以廣播的方式來維持一致性，修改資料時會通知其他 CPU</li>
      <li>Directiory: 在每個 Cache line 上都有一個 Directory，紀錄最新的資料在那些 Cache，這樣就只需要通知有關的 CPU
        <ul>
          <li>但是如果核心數多起來，Directory 會變得很大，所以會有一些機制來減少 Directory 的大小，例如: Group，把一些 Core 分組，
這樣就不用紀錄所有的 Core，通知 Group 就可以了</li>
        </ul>
      </li>
      <li>目前通常會使用 Snooping + Directory 的做法</li>
    </ul>
  </li>
</ul>

<p>對 OS 來說這些方法不重要，重點是 CPU 保證所有的 Core <strong>最終</strong>看到的資料都是一致的。</p>

<blockquote class="block-danger">
  <p>如果要保證所有的 Core 在 LLC 看到的資料都是一致的，他的成本會很高，因此現在許多的 CPU 僅僅保證「部分指令」對於記憶體系統的存取是 Atomic operation</p>
</blockquote>

<h5 id="516-dma-with-cache-coherence">5.16 DMA with Cache Coherence</h5>

<blockquote>
  <p>能夠去修改記憶體的裝置有 CPU 還有周邊的 Device，例如: NIC, GPU</p>
</blockquote>

<p>之前談的 Cache coherence 都是針對 CPU，但是實際上有去修改 Memory 的裝置都應該要去考慮同步的問題，因為 DMA 通常比較慢的原因，
因此要確保 DMA 搬移到 Memory 後，CPU 也能看到最新的資料，有軟硬體的方式可以來做到。因為是 OS 的課程，所以這裡要討論的是對於我們寫<strong>程式會有什麼影響</strong>。</p>

<ul>
  <li>以軟體的方式來做的話
    <ul>
      <li>Linux 中 CPU 把資料寫入到 DMA 會搬移的資料時，會讓 Cache 的資料 flush 到 DRAM，確保 Device 拿到的資料是最新的</li>
      <li>DMA 寫入 DRAM 後，CPU 要取這筆資料時會去把 Cache 的資料清除，並且重新從 DRAM 讀取，確保 CPU 拿到的資料是最新的</li>
    </ul>
  </li>
  <li>以硬體來說，要寫入時可以去找尋最新資料的位置在哪
    <ul>
      <li>在 DRAM: 就直接寫入 DRAM 更新資料</li>
      <li>在 Cache:
        <ol>
          <li>硬體去主動把 Cache 的資料取消</li>
          <li>直接寫入 Cache</li>
        </ol>
      </li>
    </ul>
  </li>
</ul>

<blockquote>
  <p>延伸閱讀: <a href="https://www.kernel.org/doc/Documentation/DMA-API-HOWTO.txt">Dynamic DMA mapping Guide</a></p>
</blockquote>

<h5 id="517-cache-coherence-vs-atomic-operation">5.17 Cache coherence vs Atomic operation</h5>

<blockquote class="block-warning">
  <p>從 Linux Kernel 5.4 之後支援 C11 的 atomic，在 5.4 之前的版本，Linux Kernel 會使用自己的 atomic</p>
</blockquote>

<p>這裡要提出一個疑問，如果已經有 cache coherence 的機制，那為什麼還需要 atomic operation?</p>

<p>假如有以下的情況可能發生:</p>
<ol>
  <li>如果某個瞬間，兩個 core 同時對一個變數做了修改，其他 core 是否會看到同步中間的狀態，例如: alignment
    <ul>
      <li>alignment: 可能一次修改要更新兩條 cache line，此時有可能看到只更新一半的狀態</li>
    </ul>
  </li>
  <li>非常多核心的處理器中，不能保證一個 core 做出修改後會不會有傳遞的延遲
    <ul>
      <li>core1 修改 A，但還沒傳遞到 core2 的時候 core2 又修改了 A</li>
      <li>core 數量越多，資料交換的頻寬就越是效能瓶頸</li>
    </ul>
  </li>
  <li>write buffer, read buffer: 在進行操作時有沒有可能造成 write, read 沒有按照順序執行，例如: 有 cache miss 所以先執行的 write task 被 context switch
    <ul>
      <li>這裡要牽涉到的是 <a href="https://en.wikipedia.org/wiki/Memory_ordering">Memory order</a> 的問題，因為在 write buffer, read buffer 中是沒有 cache coherence 演算法的，必須要確定順序才能保證正確性</li>
      <li>如果要嚴格執行順序的話，要在這些操作之間插入 mfence</li>
    </ul>
  </li>
</ol>

<p>可能的解決方法:</p>
<ol>
  <li>讓所有對記憶體的操作都是 atomic 的，此時去 lock bus，讓其他 core 無法存取記憶體，直到這個 core 完成操作
    <ul>
      <li>在一個實際的運算中可能每 3-4 個指令就會有 load, store，這樣的話等於要頻繁的去 lock bus 不太現實</li>
    </ul>
  </li>
  <li>部分指令對於一個記憶體區間內是 atomically，這樣會比較好設計
    <ul>
      <li>軟體與硬體工程師設計好哪些指令去解決問題</li>
    </ul>
  </li>
</ol>

<p><strong>Kaby Lake - Microarchitecture Intel</strong></p>

<p><img src="/image/2023/11-09-synchronization/13.png" alt="" height="100%" width="100%" /></p>

<p><strong>Load buffer &amp; Store buffer in x86</strong></p>

<p><img src="/image/2023/11-09-synchronization/14.png" alt="" height="100%" width="100%" /></p>

<h5 id="518-atomic-operation">5.18 Atomic operation</h5>

<p>因為想要使所有的 load, store 都是 atomic 實在太難設計，因此只保證部分指令是 atomic</p>
<ul>
  <li>傳統上會有 test_n_set, swap 這樣的 Assembly
    <ul>
      <li>test_n_set: 回傳舊的值，並且把新的值寫入，swap: 交換兩個值</li>
      <li>這兩個程式相當於以下 c 程式，register 相當於 CPU 內部真實的暫存器</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">test_n_set</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">register</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="o">*</span><span class="n">value</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>     <span class="cm">/* Update memory */</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">swap</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">register</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">;</span>
    <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>        <span class="cm">/* Update memory */</span>
    <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>       <span class="cm">/* Update memory */</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li><code class="language-plaintext highlighter-rouge">while(test_n_set(&amp;lock))</code>
    <ul>
      <li>一個簡單的 spinlock 這樣實作，但是他會不斷去更新 value，觸發 cache coherence</li>
      <li>另外這兩個指令都是 read-modify-write，會讓 cache coherence 變得沒有效率</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">bool atomic_compare_exchange_strong (volatile atomic_int* obj, int* expected, int desired )</code> 是改進的方式
    <ul>
      <li>如果 obj 等於 expected，那麼就會更新 obj 並且回傳 true</li>
      <li>如果 obj 不等於 expected，那麼就會把 obj 的值更新到 expected，並且回傳 false</li>
    </ul>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">bool</span> <span class="nf">atomic_compare_exchange_strong</span> <span class="p">(</span><span class="k">volatile</span> <span class="n">atomic_int</span><span class="o">*</span> <span class="n">obj</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">expected</span><span class="p">,</span> <span class="kt">int</span> <span class="n">desired</span> <span class="p">);{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">obj</span> <span class="o">==</span> <span class="n">expected</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Only obj equals expected to lock and write obj */</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="n">desired</span><span class="p">;</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> 
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">expected</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* Only read obj */</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<ul>
  <li>這樣的寫法不會去不斷更新 value，因此也只會觸發一次 write 造成 cache coherence
    <ul>
      <li>但是這裡並沒有保證誰會先發現 obj == expected，這部分要軟體去設計</li>
    </ul>
  </li>
</ul>

<h5 id="519-atomic-operation-in-c11">5.19 Atomic operation in c11</h5>

<p>c11 提供了一個類似 test_n_set 的支援，把 obj 與 desired swap，並且回傳舊的值</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">atomic_exchange</span><span class="p">(</span><span class="n">atomict_int</span> <span class="o">*</span><span class="n">obj</span><span class="p">,</span> <span class="kt">int</span> <span class="n">desired</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">register</span> <span class="n">tmp</span> <span class="o">=</span> <span class="o">*</span><span class="n">obj</span><span class="p">;</span>
    <span class="o">*</span><span class="n">obj</span> <span class="o">=</span> <span class="n">desired</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">tmp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>同樣也有 <code class="language-plaintext highlighter-rouge">atomic_compare_exchange_n</code>，的支援，對於 strong, weak 的差別:</p>
<ul>
  <li>在 x86 平台上的時候，strong, weak 沒有差別，因為 x86 會保證誰先發現 obj == expected</li>
  <li>strong: 保證一定會更新 obj，只有在 obj != expected 時才會回傳 false</li>
  <li>weak: 不保證一定會更新 obj，有可能因為平台造成 obj == expected 時回傳 false
    <ul>
      <li>此時可以使用 while loop 來包裝使用 weak，直到成功為止</li>
    </ul>
  </li>
</ul>

<blockquote class="block-warning">
  <p>應用上如果只需要執行一次，那就使用 strong，如果需要重複執行，那就使用 weak</p>
</blockquote>

<p>例如說一個 Initialize 的操作，只需要執行一次並且不會重置 initialized 為 0，所以只有一個 process 會成功</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">initialize_once</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">atomic_compare_exchange_strong</span><span class="p">(</span><span class="o">&amp;</span><span class="n">initialized</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">expected</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="cm">/* If this line is executed, the process is the first to successfully initialize */</span>
        <span class="n">resource</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* Resource was already initialized by another process */</span>
<span class="p">}</span>
</code></pre></div></div>
<p>一個簡單的範例，在於如何實現多個 thread 對於同一個變數做 +1 的操作，<a href="https://gist.github.com/Hotshot824/c2b4d3b073159c91f2a8e3bf11a37271">compare-exchange-spinlock.c</a></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="nf">Counter</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">expected</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10000000</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">do</span> <span class="p">{</span>
            <span class="n">expected</span> <span class="o">=</span> <span class="n">counter</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_compare_exchange_weak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">counter</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">expected</span><span class="p">,</span> <span class="n">expected</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>上面會在每次 while 之前都去先把 expected 更新成 counter，然後去比較 counter == expected，如果是的話就更新 counter，並且回傳 true，否則回傳 false</p>

<h3 id="spinlock">Spinlock</h3>

<p><a href="./2023-11-09-synchronization.html#520-spinlock-concept-and-advanced">5.20 Spinlock Concept and Advanced</a></p>

<h5 id="520-spinlock-concept-and-advanced">5.20 Spinlock Concept and Advanced</h5>

<ul>
  <li>Spinlock 的設技巧:
    <ul>
      <li>「檢查 -&gt; 鎖住」這樣的方法是不對的，在檢查和進入之間有其他 task 做「檢查」，導致多個 task 同時進入</li>
    </ul>
  </li>
  <li>「鎖住 -&gt; 檢查 -&gt; 進入」:
    <ul>
      <li>「鎖住」的目的是先讓別人進不去，再去檢查能否進入</li>
      <li>如果改變完發現不能進入，那就把「鎖住」的狀態改回來</li>
    </ul>
  </li>
  <li>「檢查和鎖住」用同一個 atomic operation，例如:
    <ul>
      <li>swap, test_n_set (效率最差)</li>
      <li>compare_exchange_weak, compare_exchange_strong (比較好，但效率還是不好)</li>
    </ul>
  </li>
</ul>

<h5 id="521-lockfreequeuec">5.21 lockfreeQueue.c</h5>

<p>如果使用 Lock-free 的方式會比使用 Semaphore 快上數倍，但程式的複雜度也會提高</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">volatile</span> <span class="kt">int</span> <span class="n">in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">put</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="kt">int</span> <span class="n">item</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* Using to debug, Ensure that the numbers are an increasing sequence */</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">in</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">bufsize</span> <span class="o">==</span> <span class="n">out</span><span class="p">)</span> <span class="p">;</span> <span class="cm">/* busy waiting */</span>
    <span class="n">buffer</span><span class="p">[</span><span class="n">in</span><span class="p">]</span><span class="o">=</span><span class="n">item</span><span class="o">++</span><span class="p">;</span>  <span class="cm">/* put item into buffer */</span>
    <span class="cm">/* A memory fence should be added here to ensure that get() reads the data after item++ */</span>
    <span class="n">in</span> <span class="o">=</span> <span class="p">(</span><span class="n">in</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">bufsize</span><span class="p">;</span> <span class="cm">/* The next position to put */</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">get</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">tmpItem</span><span class="p">;</span>    <span class="cm">/* temporary variable to store the item */</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">in</span> <span class="o">==</span> <span class="n">out</span><span class="p">)</span> <span class="p">;</span>     <span class="cm">/* busy waiting */</span>
    <span class="n">tmpItem</span><span class="o">=</span><span class="n">buffer</span><span class="p">[</span><span class="n">out</span><span class="p">];</span>    <span class="cm">/* get item from buffer */</span>
    <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">%</span><span class="n">bufsize</span><span class="p">;</span> <span class="cm">/* The next position to get */</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote class="block-warning">
  <h5 id="last-edit">Last Edit</h5>
  <p>12-08-2023 16:03</p>
</blockquote>

</section>
            </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div></div>
        <div class="normal">
            <section class="normal">
                
                <i class="fa fa-eye"></i>
                <span id="page-hit-tracker"></span>, 
                <i class="fa fa-archive"></i>
                
                OS
                
                
            </section>
        </div>
    </div>
<script async src="https://www2.cs.ccu.edu.tw/~xbs112m/tracker.php"></script>
</div>

<!-- introduce mathjax support -->
<script>
window.MathJax = {
  tex: {
    inlineMath: [ ['$', '$'], ['\\(', '\\)'] ]
  },
  svg: {
    fontCache: 'global'
  }
};
</script>
<script
  type="text/javascript" id="MathJax-script" async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js">
</script>


<!-- introduce per-page mermaid support -->


<!-- introduce mathjax support -->
<script>
    function fixes_chrome_anchors() {
        let chrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
        if (window.location.hash && chrome) {
            setTimeout(function () {
                var hash = window.location.hash;
                window.location.hash = "";
                window.location.hash = hash;
            }, 300);
        }
    }

    if (document.readyState === "loading") {
        // Loading hasn't finished yet
        document.addEventListener("DOMContentLoaded", fixes_chrome_anchors);
    } else {
        // `DOMContentLoaded` has already fired
        fixes_chrome_anchors();
    }
</script>

<!-- customize line 38-50 swap next previous-->
                    
                        <a href="/jekyll/2023-11-23-based_on_clp_testcases.html" class="navigation navigation-prev navigation-unique" aria-label="Previous page: Testing | Method-Level Functional Unit Testing">
                            <i class="fa fa-angle-left"></i>
                        </a>
                    

                    
                        <a href="/jekyll/2023-10-28-method_level_function_unit_testing.html" class="navigation navigation-next navigation-unique" aria-label="Next page: Testing | Based on CLP Testcases">
                            <i class="fa fa-angle-right"></i>
                        </a>
                    
                </div>
            </div>

            <script>
            var gitbook = gitbook || [];
            gitbook.push(function() {
                gitbook.page.hasChanged({
    "page": {
        "title": "Introduction",
        "level": "1.1",
        "depth": 1,
        
        "next": {
            "title": "Testing | Based on CLP Testcases",
            "level": "1.2",
            "depth": 1,
            "path": "_posts/2023/2023-11-23-based_on_clp_testcases.md",
            "ref": "_posts/2023/2023-11-23-based_on_clp_testcases.md",
            "articles": []
        },
        
        "dir": "ltr"
    },    "config": {
        "plugins": ["fontsettings", "highlight", "livereload", "lunr", "search", "sharing", "theme-default", "livereload"],
        "styles": {
            "ebook": "styles/ebook.css",
            "epub": "styles/epub.css",
            "mobi": "styles/mobi.css",
            "pdf": "styles/pdf.css",
            "print": "styles/print.css",
            "website": "styles/website.css"
        },
        "pluginsConfig": {
            "expandable-chapter-small2": {
                "articlesExpand": true,
            },
            "fontsettings": {
                "family": "sans",
                "size": 1,
                "theme": "white"
            },
            "highlight": {},
            "livereload": {},
            "lunr": {
                "ignoreSpecialCharacters": false,
                "maxIndexSize": 1000000
            },
            "search": {},            "sharing": {
                "facebook": false,

                "google": false,

                "github": true,
              
                "github_link": "https://github.com",
              

                "telegram": false,
                "telegram_link": "https://t.me",

                "instapaper": false,

                "twitter": false,
              

                "vk": false,

                "weibo": false,

                // "all": ["facebook", "google", "twitter", "weibo", "instapaper", "github", "telegram"]
            },
"theme-default": {
                "showLevel": false,
                "styles": {
                    "ebook": "styles/ebook.css",
                    "epub": "styles/epub.css",
                    "mobi": "styles/mobi.css",
                    "pdf": "styles/pdf.css",
                    "print": "styles/print.css",
                    "website": "styles/website.css"
                }
            },
        },
        "theme": "default",
        "author": "Tao He",
        "pdf": {
            "pageNumbers": true,
            "fontSize": 12,
            "fontFamily": "Arial",
            "paperSize": "a4",
            "chapterMark": "pagebreak",
            "pageBreaksBefore": "/",
            "margin": {
                "right": 62,
                "left": 62,
                "top": 56,
                "bottom": 56
            }
        },
        "structure": {
            "langs": "LANGS.md",
            "readme": "Home.md",
        },
        "variables": {},
        "title": "Home",
        "language": "en",
        "gitbook": "*"
    },
    "file": {
        "path": "_posts/2023/2023-11-09-synchronization.md",
        "mtime": "2023-11-09 00:00:00 +0000",
        "type": "markdown"
    },
    "gitbook": {
        "version": "3.2.3",
        "time": "2026-02-18 08:41:21 +0000"
    },
    "basePath": "",
    "book": {
        "language": ""
    }
});
            });
            </script>
        </div><script src="/assets/gitbook/gitbook.js"></script>
<script src="/assets/gitbook/theme.js"></script>

<script src="/assets/gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>
<script src="/assets/gitbook/gitbook-plugin-copy-code-button/toggle.js"></script>
<script src="/assets/gitbook/gitbook-plugin-expandable-chapters-small2/expandable-chapters-small.js"></script>
<script src="/assets/gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="/assets/gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
<script src="/assets/gitbook/gitbook-plugin-search-pro/search.js"></script>
<script src="/assets/gitbook/gitbook-plugin-sharing/buttons.js"></script>
<script src="/assets/gitbook/gitbook-plugin-splitter/splitter.js"></script>

<!--
<script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
<script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
<script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
<script src="../gitbook/gitbook-plugin-search/search.js"></script>
-->

</body>
</html>